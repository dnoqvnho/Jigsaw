diff --git a/Makefile b/Makefile
index a3f9f43..a2dcf4d 100644
--- a/Makefile
+++ b/Makefile
@@ -3,15 +3,19 @@
 # For the MPI version, call as `make CPPFLAGS=-DENABLE_MPI`.
 # Do `export MV2_ENABLE_AFFINITY=0` before starting for the MPI operator.
 # 
-.PHONY: all clean doc distclean unit_tests drivers tags util/timestamp.o
+.PHONY: all clean doc distclean unit_tests drivers baseline_driver \
+		partition_driver partition_seq_driver \
+		partition_lockfree_driver partition_lockfree_seq_driver \
+		tags util/timestamp.o
 
 include system.inc
 
 override CPPFLAGS+=-Idist/include/
 
-CXXFLAGS+=-g 
-CXXFLAGS+=-O0 -Wall
-#CXXFLAGS+=-O3 -Wall
+#CXXFLAGS+=-g 
+#CXXFLAGS+=-O0 -Wall
+CXXFLAGS+=-O3 -Wall
+#CXXFLAGS+=-pedantic
 
 LDFLAGS+=-Ldist/lib/
 LDLIBS+=-lconfig++ -lpthread -lrt -lbz2
@@ -183,6 +187,9 @@ UNIT_TESTS += \
 
 endif
 
+#UNIT_TESTS += \
+#	unit_tests/partitions/test_hashtabled \
+
 UNIT_TESTS += \
 	unit_tests/testlibconfig \
 	unit_tests/testschema \
@@ -280,6 +287,86 @@ endif
 
 DRIVER_OBJS = $(DRIVERS)
 
+
+BASELINE_FILE = util/baselines/baselinequery.o \
+				  util/baselines/index.o \
+				  util/baselines/partition.o \
+				  util/baselines/tablecolumn.o \
+				  util/baselines/tablerow.o \
+				  util/partitions/profiler.o \
+				  util/partitions/readdummy.o \
+				  operators/baselines/column/filtercolumn.o \
+				  operators/baselines/column/parallelscancolumn.o \
+				  operators/baselines/column/projectcolumn.o \
+				  operators/baselines/row/filterrow.o \
+				  operators/baselines/row/parallelscanrow.o \
+				  operators/baselines/row/projectrow.o 
+
+BASELINE_DRIVER = drivers/baselines/executequery-column \
+					drivers/baselines/executequery-row
+
+BASELINE_DRIVER_OBJS = $(BASELINE_DRIVER)
+
+PARTITION_FILE = util/partitions/hashtabledelete.o \
+				 util/partitions/index.o \
+				 util/partitions/segment.o \
+				 util/partitions/partition.o \
+				 util/partitions/partitionquery.o \
+				 util/partitions/readdummy.o \
+				 util/partitions/profiler.o \
+				 util/partitions/profiler_cycle.o \
+				 operators/partitions/filterhv.o \
+				 operators/partitions/projecthv.o
+
+PARTITION_DRIVER = drivers/partitions/executequery-hv
+
+PARTITION_DRIVER_OBJS = $(PARTITION_DRIVER)
+
+PARTITION_SEQ_FILE = util/partitions/hashtabledelete.o \
+				 util/partitions/index.o \
+				 util/partitions/segment.o \
+				 util/partitions/partition.o \
+				 util/partitions/partitionquery.o \
+				 util/partitions/readdummy.o \
+				 util/partitions/profiler.o \
+				 util/partitions/profiler_trace.o \
+				 operators/partitions/filterhv-seq.o \
+				 operators/partitions/projecthv-seq.o
+
+PARTITION_SEQ_DRIVER = drivers/partitions/executequery-hv-seq
+
+PARTITION_SEQ_DRIVER_OBJS = $(PARTITION_SEQ_DRIVER)
+
+PARTITION_LOCKFREE_FILE = util/partitions/hashtabledelete.o \
+				 util/partitions/index.o \
+				 util/partitions/segment.o \
+				 util/partitions/partition.o \
+				 util/partitions/partitionquery.o \
+				 util/partitions/readdummy.o \
+				 util/partitions/profiler.o \
+				 util/partitions/profiler_cycle.o \
+				 operators/partitions/filterhv-lock-free.o \
+				 operators/partitions/projecthv-lock-free.o
+
+PARTITION_LOCKFREE_DRIVER = drivers/partitions/executequery-hv-lock-free
+
+PARTITION_LOCKFREE_DRIVER_OBJS = $(PARTITION_LOCKFREE_DRIVER)
+
+PARTITION_LOCKFREE_SEQ_FILE = util/partitions/hashtabledelete.o \
+				 util/partitions/index.o \
+				 util/partitions/segment.o \
+				 util/partitions/partition.o \
+				 util/partitions/partitionquery.o \
+				 util/partitions/readdummy.o \
+				 util/partitions/profiler.o \
+				 util/partitions/profiler_trace.o \
+				 operators/partitions/filterhv-lock-free-seq.o \
+				 operators/partitions/projecthv-lock-free-seq.o
+
+PARTITION_LOCKFREE_SEQ_DRIVER = drivers/partitions/executequery-hv-lock-free-seq
+
+PARTITION_LOCKFREE_SEQ_DRIVER_OBJS = $(PARTITION_LOCKFREE_SEQ_DRIVER)
+
 all: dist tests $(DRIVER_OBJS)
 
 tests: $(UNIT_TEST_OBJS) $(MPI_TEST_OBJS) $(RDMA_TEST_OBJS)
@@ -310,6 +397,16 @@ clean:
 	rm -f $(RDMA_TEST_OBJS)
 	rm -f $(DRIVER_OBJS)
 	rm -f util/timestamp.o
+	rm -f $(BASELINE_DRIVER)
+	rm -f $(BASELINE_FILE)
+	rm -f $(PARTITION_DRIVER)
+	rm -f $(PARTITION_FILE)
+	rm -f $(PARTITION_SEQ_DRIVER) 
+	rm -f $(PARTITION_SEQ_FILE)
+	rm -f $(PARTITION_LOCKFREE_DRIVER)
+	rm -f $(PARTITION_LOCKFREE_FILE)
+	rm -f $(PARTITION_LOCKFREE_SEQ_DRIVER)
+	rm -f $(PARTITION_LOCKFREE_SEQ_FILE)
 
 distclean: clean
 	rm -rf dist
@@ -324,6 +421,16 @@ tags:
 
 drivers: $(DRIVER_OBJS)
 
+baseline_driver: $(BASELINE_DRIVER_OBJS)
+
+partition_driver: $(PARTITION_DRIVER_OBJS)
+
+partition_seq_driver: $(PARTITION_SEQ_DRIVER_OBJS)
+
+partition_lockfree_driver: $(PARTITION_LOCKFREE_DRIVER_OBJS)
+
+partition_lockfree_seq_driver: $(PARTITION_LOCKFREE_SEQ_DRIVER_OBJS)
+
 util/timestamp.o:
 	rm -f util/timestamp.cpp
 	echo -n "const char* MakefileTimestampSignature=\"" >> util/timestamp.cpp
@@ -351,5 +458,15 @@ $(RDMA_TEST_OBJS): $(FILES)
 $(DRIVER_OBJS): $(FILES) util/timestamp.o 
 	$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(subst $(EXECSUFFIX),,$@.cpp) $^ $(LDLIBS) -o $@
 
+$(BASELINE_DRIVER_OBJS): $(FILES) $(BASELINE_FILE)
+
+$(PARTITION_DRIVER_OBJS): $(FILES) $(PARTITION_FILE)
+
+$(PARTITION_SEQ_DRIVER_OBJS): $(FILES) $(PARTITION_SEQ_FILE)
+
+$(PARTITION_LOCKFREE_DRIVER_OBJS): $(FILES) $(PARTITION_LOCKFREE_FILE)
+
+$(PARTITION_LOCKFREE_SEQ_DRIVER_OBJS): $(FILES) $(PARTITION_LOCKFREE_SEQ_FILE)
+
 dist:
 	./pre-init.sh
diff --git a/drivers/baselines/executequery-column.cpp b/drivers/baselines/executequery-column.cpp
new file mode 100644
index 0000000..3b2d234
--- /dev/null
+++ b/drivers/baselines/executequery-column.cpp
@@ -0,0 +1,459 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdlib.h>
+#include <string>
+#include <vector>
+#include <fstream>
+#include <typeinfo>
+#include <iostream>
+#include <cstdint>
+#include <unistd.h>
+
+#include "libconfig.h++"
+#include "../../query.h"
+#include "../../operators/operators.h"
+#include "../../visitors/allvisitors.h"
+#include "../../rdtsc.h"
+#include "../../util/baselines/index.h"
+#include "../../util/baselines/baselinequery.h"
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/profiler.h"
+#include "../../util/partitions/readdummy.h"
+
+#include "../../operators/baselines/column/parallelscancolumn.h"
+#include "../../operators/baselines/column/filtercolumn.h"
+#include "../../operators/baselines/column/projectcolumn.h"
+
+using namespace std;
+using namespace libconfig;
+
+extern Profiler io_profiler[128];
+
+void fail(const char* explanation) {
+    std::cout << " ** FAILED: " << explanation << std::endl;
+    throw QueryExecutionError();
+}
+
+
+void select(BaselineQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, bitset<TNUM>* bitmap); 
+
+uint64_t project(BaselineQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, bitset<TNUM>* bitmap, vector<VTYPE>* ret);
+
+void evaluate_direct(BaselineQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret);
+
+bool compare_random(vector<VTYPE> &ret, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num);
+
+int main(const int argc, const char* argv[]){
+    bool flush = false;
+    if (argc == 6)
+        flush = true;
+    string qpath = argv[1];
+    string datadir = argv[2];
+    string indexpath = argv[3];
+    int threadnum = atoi(argv[4]);
+    //string orgpath = argv[5];
+
+    Index* index = Index::readFromFile(indexpath.c_str());
+    
+    /*
+    string clear_cache_file = argv[5];
+    int clear_file_num = atoi(argv[6]);
+    uint64_t clear_buf_size = 1024*1024*1024;
+    //char* clear_buf = new char[clear_buf_size];
+    */
+
+    ifstream qfile(qpath);
+    string qstr;
+    
+    Profiler total;
+    int q_num = 0;
+    while(getline(qfile, qstr)){
+        Profiler one_query_time;
+        //clear the memory cache
+        if (flush)
+        {
+            string clear_cache_path = argv[5];
+            system(clear_cache_path.c_str());
+        }
+
+        BaselineQuery<VTYPE>* q = BaselineQuery<VTYPE>
+                    ::parse_string(qstr);
+        bitset<TNUM>* sel_ret = new bitset<TNUM>();
+        
+        one_query_time.start_timer();
+        total.start_timer();
+        select(q, index, datadir, threadnum, sel_ret);
+        uint64_t tnum = project(q, index, datadir, threadnum, sel_ret
+                , NULL);
+        one_query_time.stop_timer();
+        total.stop_timer();
+
+        
+        /*        
+        one_query_time.start_timer();
+        total.start_timer();
+        select(q, index, datadir, threadnum, sel_ret);
+        vector<VTYPE> ret;
+        uint64_t tnum = project(q, index, datadir, threadnum, sel_ret
+                , &ret);
+        one_query_time.stop_timer();
+        total.stop_timer();
+        cout << "number of result tuples " << tnum << endl;
+        
+        vector<VTYPE> direct_ret;
+        evaluate_direct(q, orgpath.c_str(), direct_ret);
+        bool eq = compare_random(ret, direct_ret, q->projection.count()
+                , 10);
+        if(!eq)
+            fail("Compare not pass");
+        */
+       
+
+        delete sel_ret;
+        delete q;
+        cout << "query " << q_num << " : " << one_query_time.getTime() << " seconds" << endl;
+        
+        for(int i = 0; i < threadnum; i++){
+            printf("Query %d Thread %d I/O time %f seconds\n", q_num, i
+                    , io_profiler[i].getTime());
+            printf("Query %d Thread %d I/O size %lu bytes\n", q_num, i
+                    , io_profiler[i].getIOSize());
+            printf("Query %d Thread %d I/O num %lu times\n", q_num, i
+                    , io_profiler[i].getIONum());
+            
+            io_profiler[i].clear();
+        }
+        
+        q_num++;
+
+        //system("free -m"); 
+        //break;
+    }
+
+    
+    qfile.close();
+    delete index;
+    //delete[] clear_buf;
+    return 0;
+}
+
+void select(BaselineQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, bitset<TNUM>* bitmap){
+    
+    int buffsize = 1024*1024;
+
+    Query query;
+    Config cfg;
+
+    cfg.getRoot().add("path", Setting::TypeString) = datadir;
+    cfg.getRoot().add("buffsize", Setting::TypeInt) = buffsize;
+
+    vector<int> pred_attrs;
+
+    //create parallel scan
+    Setting& scannode = cfg.getRoot().add("scanop", Setting::TypeGroup);
+    {
+        scannode.add("index", Setting::TypeInt64) = (int64_t)index;
+        scannode.add("thread_num", Setting::TypeInt) = threadnum;
+        Setting& attrs = scannode.add("attributes", Setting::TypeArray);
+        for(int i = 0; i < ANUM; i++)
+            if(q->selection[i]){
+                attrs.add(Setting::TypeInt) = i;
+                pred_attrs.push_back(i);
+            }
+    }
+
+    //create filter
+    Setting& filternode = cfg.getRoot().add("filterop"
+            , Setting::TypeGroup);
+    {
+        Setting& ranges = filternode.add("ranges", Setting::TypeArray);
+        Setting& equal = filternode.add("equal", Setting::TypeArray);
+
+        Setting::Type vtype = Setting::TypeInt;
+        if(typeid(VTYPE) == typeid(double) ||
+                typeid(VTYPE) == typeid(float))
+            vtype = Setting::TypeFloat;
+        for(int i = 0; i < pred_attrs.size(); i++){
+            ranges.add(vtype) = q->ranges[pred_attrs[i] * 2];
+            ranges.add(vtype) = q->ranges[pred_attrs[i] * 2 + 1];
+            equal.add(Setting::TypeBoolean) = 
+                (q->closed[pred_attrs[i] * 2] == 1);
+            equal.add(Setting::TypeBoolean) = 
+                (q->closed[pred_attrs[i] * 2 + 1] == 1);
+        }
+    }
+
+    //create mergeop
+    Setting& mergenode = cfg.getRoot().add("merge"
+            , Setting::TypeGroup);
+    {
+        mergenode.add("threads", Setting::TypeInt) = threadnum;
+    }
+
+    MergeOp node1;
+    FilterColumnOp node2;
+    ParallelScanColumnOp node3;
+
+    query.tree = &node1;
+    node1.nextOp = &node2;
+    node2.nextOp = &node3;
+
+    node1.init(cfg, mergenode);
+    node2.init(cfg, filternode);
+    node3.init(cfg, scannode);
+
+    query.threadInit();
+    if (query.scanStart() != Operator::Ready) {
+        fail("Scan initialization failed.");
+    }
+    
+    Operator::GetNextResultT result;
+    Operator::Page* out;
+    while(result.first == Operator::Ready){
+        result = query.getNext();
+        out = result.second;
+
+        Operator::Page::Iterator it = out->createIterator();
+        uint64_t* tuple;
+        while((tuple = (uint64_t*)it.next())){
+            bitmap->set(*tuple);
+        }
+    }
+
+    assert(result.first != Operator::Error);
+    if (query.scanStop() != Operator::Ready) {
+        fail("Scan stop failed.");
+    }
+
+    query.threadClose();
+    query.destroynofree();
+    
+}
+
+uint64_t project(BaselineQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, bitset<TNUM>* bitmap, vector<VTYPE>* ret){
+    
+    int buffsize = 1024*1024;
+    
+    Query query;
+    Config cfg;
+
+    cfg.getRoot().add("path", Setting::TypeString) = datadir;
+    cfg.getRoot().add("buffsize", Setting::TypeInt) = buffsize;
+    
+    //create parallel scan
+    int project_anum = 0;
+    Setting& scannode = cfg.getRoot().add("scanop", Setting::TypeGroup);
+    {
+        scannode.add("index", Setting::TypeInt64) = (int64_t)index;
+        scannode.add("thread_num", Setting::TypeInt) = threadnum;
+        Setting& attrs = scannode.add("attributes", Setting::TypeArray);
+        for(int i = 0; i < ANUM; i++)
+            if(q->projection[i]){
+                attrs.add(Setting::TypeInt) = i;
+                project_anum ++;
+            }
+        scannode.add("tuples", Setting::TypeInt64) = (int64_t)bitmap;
+    }
+
+    //create projectop
+    Setting& projectnode = cfg.getRoot().add("projectop"
+                , Setting::TypeGroup);
+    {
+        projectnode.add("tuples", Setting::TypeInt64) = (int64_t)bitmap;
+        projectnode.add("attribute_num", Setting::TypeInt) = project_anum;
+    }
+    
+    //create mergeop
+    Setting& mergenode = cfg.getRoot().add("merge"
+            , Setting::TypeGroup);
+    {
+        mergenode.add("threads", Setting::TypeInt) = threadnum;
+    }
+
+    MergeOp node1;
+    ProjectColumnOp node2;
+    ParallelScanColumnOp node3;
+
+    query.tree = &node1;
+    node1.nextOp = &node2;
+    node2.nextOp = &node3;
+
+    node1.init(cfg, mergenode);
+    node2.init(cfg, projectnode);
+    node3.init(cfg, scannode);
+
+    query.threadInit();
+    if (query.scanStart() != Operator::Ready) {
+        fail("Scan initialization failed.");
+    }
+    
+    Operator::GetNextResultT result;
+    Operator::Page* out;
+    uint64_t tnum = 0;
+
+    if(ret != NULL)
+        ret->clear();
+
+    if(ret != NULL){
+        ret->reserve(project_anum * bitmap->count());
+    }
+    while(result.first == Operator::Ready){
+        result = query.getNext();
+        out = result.second;
+        tnum += out->getNumTuples();
+
+        if(ret != NULL){
+            Operator::Page::Iterator it = out->createIterator();
+            VTYPE* tuple;
+            while((tuple = (VTYPE*)it.next())){
+                for(int i = 0; i < project_anum; i++)
+                    ret->push_back(tuple[i]);
+            }
+            
+        }
+    }
+
+    assert(result.first != Operator::Error);
+    if (query.scanStop() != Operator::Ready) {
+        fail("Scan stop failed.");
+    }
+
+    query.threadClose();
+    query.destroynofree();
+    
+    return tnum;
+}
+
+void evaluate_direct(BaselineQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret){
+
+    ret.clear();
+
+    ifstream ifile(data_path, ios::binary);
+    uint64_t btnum = 1024*1024;
+    uint64_t btsize = btnum * ANUM;
+    VTYPE* buffer = new VTYPE[btsize];
+    uint64_t tnum = 0;
+
+    vector<VTYPE> tmp;
+    do{
+      ifile.read((char*) buffer, btsize * sizeof(VTYPE));
+      uint64_t len = ifile.gcount();
+      if(len % (sizeof(VTYPE)*ANUM) != 0){
+          delete[] buffer;
+          ifile.close();
+      }
+      len = len / sizeof(VTYPE) / ANUM;
+
+      vector<uint64_t> tids;
+      query->evaluate(buffer, len, tmp, tids);
+
+      /*for(auto i : tids)
+          printf("%lu\n", i + tnum);*/
+
+      ret.insert(ret.end(), tmp.begin(), tmp.end());
+      tnum += len;
+    }while(tnum < TNUM);
+
+    delete[] buffer;
+    ifile.close();
+}
+
+bool compare_random(vector<VTYPE> &ret, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num){
+    /*cout << "ret size " << ret.size() << endl;
+    cout << "direct size " << ret_direct.size() << endl;
+
+    int* rc = new int[TNUM];
+    int* dc = new int[TNUM];
+
+    for(int i = 0; i < TNUM; i++)
+        rc[i] = dc[i] = 0;
+
+    for(uint64_t i = 0; i < ret.size(); i += proj_num)
+        rc[ret[i]]++;
+    for(uint64_t i = 0; i < ret_direct.size(); i += proj_num)
+        dc[ret_direct[i]]++;
+
+    for(uint64_t i = 0; i < TNUM; i++)
+        if(rc[i] != dc[i]){
+            printf("%lu %d %d\n", i, rc[i], dc[i]);
+            cout << "ret" << endl;
+            for(uint64_t j = 0; j < ret.size(); j+=proj_num)
+                if(ret[j] == i){
+                    for(int k = 0; k < proj_num; k++)
+                        cout << ret[j + k] << " ";
+                    cout << endl;
+                }
+            cout <<"direct"<< endl;
+            for(uint64_t j = 0; j < ret_direct.size(); j+=proj_num)
+                if(ret_direct[j] == i){
+                    for(int k = 0; k < proj_num; k++)
+                        cout << ret_direct[j + k] << " ";
+                    cout << endl;
+                }
+        }
+
+    delete[] rc;
+    delete[] dc;*/
+
+    if(ret.size() != ret_direct.size())
+        return false;
+
+    for(uint64_t i = 0; i < num; i++){
+        uint64_t tid = rand() % (ret.size()/proj_num);
+
+        /*for(int j = 0; j < proj_num; j++)
+            cout << ret[tid*proj_num + j] << " ";
+        cout << endl;*/
+
+        bool exist = false;
+        for(uint64_t j = 0; j < ret.size() && !exist; j+= proj_num){
+            bool eq = true;
+            for(int k = 0; k < proj_num && eq; k++)
+                if(ret[tid*proj_num + k] != ret_direct[j + k])
+                    eq = false;
+            if(eq)
+                exist = true;
+        }
+        if(!exist)
+          return false;
+    }
+    return true;
+}
diff --git a/drivers/baselines/executequery-row.cpp b/drivers/baselines/executequery-row.cpp
new file mode 100644
index 0000000..d32fc73
--- /dev/null
+++ b/drivers/baselines/executequery-row.cpp
@@ -0,0 +1,392 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdlib.h>
+#include <string>
+#include <vector>
+#include <fstream>
+#include <typeinfo>
+#include <iostream>
+#include <cstdint>
+#include <unordered_map>
+
+#include "libconfig.h++"
+#include "../../query.h"
+#include "../../operators/operators.h"
+#include "../../visitors/allvisitors.h"
+#include "../../rdtsc.h"
+#include "../../util/baselines/index.h"
+#include "../../util/baselines/baselinequery.h"
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/profiler.h"
+#include "../../util/partitions/readdummy.h"
+
+#include "../../operators/baselines/row/parallelscanrow.h"
+#include "../../operators/baselines/row/filterrow.h"
+#include "../../operators/baselines/row/projectrow.h"
+
+using namespace std;
+using namespace libconfig;
+
+extern Profiler io_profiler[128];
+
+
+void fail(const char* explanation) {
+    std::cout << " ** FAILED: " << explanation << std::endl;
+    throw QueryExecutionError();
+}
+
+
+uint64_t compute(BaselineQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, vector<VTYPE>* ret);
+
+void evaluate_direct(BaselineQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret);
+
+bool compare_random(vector<VTYPE> &ret, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num);
+
+int main(const int argc, const char* argv[]){
+    bool flush = false;
+    if (argc == 6)
+        flush = true;
+    string qpath = argv[1];
+    string datadir = argv[2];
+    string indexpath = argv[3];
+    int threadnum = atoi(argv[4]);
+    //string orgpath = argv[5];
+
+    /*
+    string clear_cache_file = argv[5];
+    uint64_t clear_buf_size = 1024*1024*1024;
+    int clear_file_num = atoi(argv[6]);
+    //char* clear_buf = new char[clear_buf_size];
+    */
+    // string clear_cache_path = argv[5];
+    
+    Index* index = Index::readFromFile(indexpath.c_str());
+
+    ifstream qfile(qpath);
+    string qstr;
+    
+    Profiler total;
+    int q_num = 0;
+    while(getline(qfile, qstr)){
+        //system("free -m");
+        Profiler one_query_time;
+        //clear the memory cache
+        if (flush)
+        {
+            string clear_cache_path = argv[5];
+            system(clear_cache_path.c_str());
+        }
+
+        BaselineQuery<VTYPE>* q = BaselineQuery<VTYPE>
+                    ::parse_string(qstr);
+        
+        /*vector<VTYPE> ret;
+        ret.reserve(q->projection.count() * TNUM);
+
+        total.start_timer();
+        uint64_t tnum = compute(q, index, datadir, threadnum, &ret);
+        total.stop_timer();
+        cout << "number of result tuples " << tnum << endl;
+        
+        vector<VTYPE> direct_ret;
+        evaluate_direct(q, orgpath.c_str(), direct_ret);
+        bool eq = compare_random(ret, direct_ret, q->projection.count()
+                , 10);
+        if(!eq)
+            fail("Compare not pass");
+       */
+
+        total.start_timer();
+        one_query_time.start_timer();
+        uint64_t tnum = compute(q, index, datadir, threadnum, NULL);
+        total.stop_timer();
+        one_query_time.stop_timer();
+        
+        cout << "query " << q_num << " : " << one_query_time.getTime() << " seconds" << endl;
+        
+        for(int i = 0; i < threadnum; i++){
+            printf("Query %d Thread %d I/O time %f seconds\n", q_num, i
+                    , io_profiler[i].getTime());
+            printf("Query %d Thread %d I/O size %lu bytes\n", q_num, i
+                    , io_profiler[i].getIOSize());
+            printf("Query %d Thread %d I/O num %lu times\n", q_num, i
+                    , io_profiler[i].getIONum());
+            
+            io_profiler[i].clear();
+        }
+        
+        q_num++;
+
+        delete q;
+        
+        //system("free -m");
+        //break;
+    }
+    
+    cout << "Total time " << total.getTime() << " seconds" << endl;
+    
+    qfile.close();
+    delete index;
+    //delete[] clear_buf;
+    
+    return 0;
+}
+
+
+uint64_t compute(BaselineQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, vector<VTYPE>* ret){
+    
+    int buffsize = 1024*1024;
+
+    Query query;
+    Config cfg;
+
+    cfg.getRoot().add("path", Setting::TypeString) = datadir;
+    cfg.getRoot().add("buffsize", Setting::TypeInt) = buffsize;
+
+    unordered_map<int, int> attr_order;
+    Setting& scannode = cfg.getRoot().add("scanop", Setting::TypeGroup);
+    {
+        scannode.add("index", Setting::TypeInt64) = (int64_t)index;
+        scannode.add("thread_num", Setting::TypeInt) = threadnum;
+        Setting& attrs = scannode.add("attributes", Setting::TypeArray);
+        int order = 0;
+        for(int i = 0; i < ANUM; i++)
+            if(q->selection[i] || q->projection[i]){
+                attrs.add(Setting::TypeInt) = i;
+                attr_order[i] = order;
+                order++;
+            }
+    }
+    
+
+    //create filter
+    Setting& filternode = cfg.getRoot().add("filterop"
+            , Setting::TypeGroup);
+    {
+        Setting& ranges = filternode.add("ranges", Setting::TypeArray);
+        Setting& equal = filternode.add("equal", Setting::TypeArray);
+        Setting& attrs = filternode.add("attributes", Setting::TypeArray);
+
+        Setting::Type vtype = Setting::TypeInt;
+        if(typeid(VTYPE) == typeid(double) ||
+                typeid(VTYPE) == typeid(float))
+            vtype = Setting::TypeFloat;
+        
+        for(int i = 0; i < ANUM; i++){
+            if(!q->selection[i])
+                continue;
+            attrs.add(Setting::TypeInt) = attr_order[i];
+            ranges.add(Setting::TypeInt) = q->ranges[i*2];
+            ranges.add(Setting::TypeInt) = q->ranges[i*2 + 1];
+            equal.add(Setting::TypeBoolean) = (q->closed[i * 2] == 1);
+            equal.add(Setting::TypeBoolean) = (q->closed[i * 2 + 1] == 1);
+        }
+        filternode.add("attribute_per_tuple", Setting::TypeInt) = 
+            (int)attr_order.size();
+    }
+
+    //create project
+    Setting& projectnode = cfg.getRoot().add("projectop"
+            , Setting::TypeGroup);
+    {
+        Setting& attrs = projectnode.add("attributes"
+                , Setting::TypeArray);
+        for(int i = 0; i < ANUM; i++)
+            if(q->projection[i]){
+                attrs.add(Setting::TypeInt) = attr_order[i];
+            }
+    }
+    
+    //create mergeop
+    Setting& mergenode = cfg.getRoot().add("merge"
+            , Setting::TypeGroup);
+    {
+        mergenode.add("threads", Setting::TypeInt) = threadnum;
+    }
+    
+    MergeOp node1;
+    ProjectRowOp node2;
+    FilterRowOp node3;
+    ParallelScanRowOp node4;
+
+    query.tree = &node1;
+    node1.nextOp = &node2;
+    node2.nextOp = &node3;
+    node3.nextOp = &node4;
+    
+    node1.init(cfg, mergenode);
+    node2.init(cfg, projectnode);
+    node3.init(cfg, filternode);
+    node4.init(cfg, scannode);
+
+    query.threadInit();
+    if (query.scanStart() != Operator::Ready) {
+        fail("Scan initialization failed.");
+    }
+    
+    Operator::GetNextResultT result;
+    Operator::Page* out;
+    uint64_t tnum = 0;
+
+    if(ret != NULL)
+        ret->clear();
+
+    int project_attr_num = q->projection.count();
+    while(result.first == Operator::Ready){
+        result = query.getNext();
+        out = result.second;
+        tnum += out->getNumTuples();
+
+        if(ret != NULL){
+            Operator::Page::Iterator it = out->createIterator();
+            VTYPE* tuple;
+            while((tuple = (VTYPE*)it.next())){
+                for(int i = 0; i < project_attr_num; i++)
+                    ret->push_back(tuple[i]);
+            }
+            
+        }
+    }
+    
+    assert(result.first != Operator::Error);
+    if (query.scanStop() != Operator::Ready) {
+        fail("Scan stop failed.");
+    }
+
+    query.threadClose();
+    query.destroynofree();
+    
+    return tnum;
+}
+
+void evaluate_direct(BaselineQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret){
+
+    ret.clear();
+
+    ifstream ifile(data_path, ios::binary);
+    uint64_t btnum = 1024*1024;
+    uint64_t btsize = btnum * ANUM;
+    VTYPE* buffer = new VTYPE[btsize];
+    uint64_t tnum = 0;
+
+    vector<VTYPE> tmp;
+    do{
+      ifile.read((char*) buffer, btsize * sizeof(VTYPE));
+      uint64_t len = ifile.gcount();
+      if(len % (sizeof(VTYPE)*ANUM) != 0){
+          delete[] buffer;
+          ifile.close();
+      }
+      len = len / sizeof(VTYPE) / ANUM;
+
+      vector<uint64_t> tids;
+      query->evaluate(buffer, len, tmp, tids);
+
+      /*for(auto i : tids)
+          printf("%lu\n", i + tnum);*/
+
+      ret.insert(ret.end(), tmp.begin(), tmp.end());
+      tnum += len;
+    }while(tnum < TNUM);
+
+    delete[] buffer;
+    ifile.close();
+}
+
+bool compare_random(vector<VTYPE> &ret, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num){
+    /*cout << "ret size " << ret.size() << endl;
+    cout << "direct size " << ret_direct.size() << endl;
+
+    int* rc = new int[TNUM];
+    int* dc = new int[TNUM];
+
+    for(int i = 0; i < TNUM; i++)
+        rc[i] = dc[i] = 0;
+
+    for(uint64_t i = 0; i < ret.size(); i += proj_num)
+        rc[ret[i]]++;
+    for(uint64_t i = 0; i < ret_direct.size(); i += proj_num)
+        dc[ret_direct[i]]++;
+
+    for(uint64_t i = 0; i < TNUM; i++)
+        if(rc[i] != dc[i]){
+            printf("%lu %d %d\n", i, rc[i], dc[i]);
+            cout << "ret" << endl;
+            for(uint64_t j = 0; j < ret.size(); j+=proj_num)
+                if(ret[j] == i){
+                    for(int k = 0; k < proj_num; k++)
+                        cout << ret[j + k] << " ";
+                    cout << endl;
+                }
+            cout <<"direct"<< endl;
+            for(uint64_t j = 0; j < ret_direct.size(); j+=proj_num)
+                if(ret_direct[j] == i){
+                    for(int k = 0; k < proj_num; k++)
+                        cout << ret_direct[j + k] << " ";
+                    cout << endl;
+                }
+        }
+
+    delete[] rc;
+    delete[] dc;*/
+
+    if(ret.size() != ret_direct.size())
+        return false;
+
+    for(uint64_t i = 0; i < num; i++){
+        uint64_t tid = rand() % (ret.size()/proj_num);
+
+        /*for(int j = 0; j < proj_num; j++)
+            cout << ret[tid*proj_num + j] << " ";
+        cout << endl;*/
+
+        bool exist = false;
+        for(uint64_t j = 0; j < ret.size() && !exist; j+= proj_num){
+            bool eq = true;
+            for(int k = 0; k < proj_num && eq; k++)
+                if(ret[tid*proj_num + k] != ret_direct[j + k])
+                    eq = false;
+            if(eq)
+                exist = true;
+        }
+        if(!exist)
+          return false;
+    }
+    return true;
+}
diff --git a/drivers/partitions/executequery-hv-lock-free-seq.cpp b/drivers/partitions/executequery-hv-lock-free-seq.cpp
new file mode 100644
index 0000000..a89b6ac
--- /dev/null
+++ b/drivers/partitions/executequery-hv-lock-free-seq.cpp
@@ -0,0 +1,402 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <cstring>
+#include <cstdint>
+#include <vector>
+#include "libconfig.h++"
+
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/partitionquery.h"
+#include "../../util/partitions/index.h"
+#include "../../util/partitions/hashtabledelete.h"
+#include "../../util/partitions/readdummy.h"
+#include "../../util/partitions/profiler.h"
+
+#include "../../query.h"
+#include "../../operators/operators.h"
+#include "../../visitors/allvisitors.h"
+//#include "../../rdtsc.h"
+#include "../../operators/partitions/filterhv-lock-free-seq.h"
+#include "../../operators/partitions/projecthv-lock-free-seq.h"
+
+using namespace std;
+using namespace libconfig;
+
+#ifdef PERF
+#include "../../util/partitions/profiler_trace.h"
+ProfilerTrace trace;
+#endif
+
+extern Profiler io_profiler[128];
+
+void fail(const char* explanation) {
+    std::cout << " ** FAILED: " << explanation << std::endl;
+    throw QueryExecutionError();
+}
+
+void select(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable);
+void project(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable);
+
+void evaluate_direct(PQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret);
+bool compare_random(HashTableD* hashtable, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num);
+
+int main(const int argc, const char* argv[]){
+    bool flush = false;
+    if (argc == 6)
+        flush = true;
+    string qpath = argv[1];
+    string datadir = argv[2];
+    string indexpath = argv[3];
+    int threadnum = atoi(argv[4]);
+    // string orgpath = argv[5];
+
+    /*
+    string clear_cache_file = argv[5];
+    int clear_file_num = atoi(argv[6]);
+    uint64_t clear_buf_size = 1024*1024*1024;
+    //char* clear_buf = new char[clear_buf_size];
+    */
+    //string clear_cache_path = argv[5];
+
+    Index* index = Index::deserialize(indexpath);
+    ifstream qfile(qpath.c_str());
+    string qstr;
+   
+#ifdef PERF
+    trace.init(threadnum);
+#endif
+
+    Profiler total;
+    int q_num = 0;
+    while(getline(qfile, qstr)){
+        system("free -m");
+        Profiler one_query_time;
+        
+        //clear the memory cache
+        if (flush)
+        {
+            string clear_cache_path = argv[5];
+            system(clear_cache_path.c_str());
+        }
+        system("free -m");
+        
+        PQuery<VTYPE>* query = PQuery<VTYPE>::parse_string(qstr);
+        HashTableD* hashtable = new HashTableD();
+
+        one_query_time.start_timer();
+        total.start_timer();
+        
+#ifdef PERF
+        trace.clear();
+        trace.add(0, "start select");
+#endif
+        select(query, index, datadir, threadnum, hashtable);
+
+#ifdef PERF
+        trace.add(0, "end select");
+        trace.add(0, "start project");
+#endif
+        project(query, index, datadir, threadnum, hashtable);
+        
+        one_query_time.stop_timer();
+        total.stop_timer();
+
+#ifdef PERF
+        trace.add(0, "end project");
+        trace.print();
+#endif
+        /*
+        vector<VTYPE> direct_ret;
+        evaluate_direct(query, orgpath.c_str(), direct_ret);
+        bool eq = compare_random(hashtable, direct_ret
+                , query->projection.count(), 10);
+        if(!eq)
+            fail("Compare not pass");
+        */
+        cout << "query " << q_num << " : " << one_query_time.getTime() << " seconds" << endl;
+
+        for(int i = 0; i < threadnum; i++){
+            printf("Query %d Thread %d I/O time %f seconds\n", q_num, i
+                    , io_profiler[i].getTime());
+            printf("Query %d Thread %d I/O size %lu bytes\n", q_num, i
+                    , io_profiler[i].getIOSize());
+            printf("Query %d Thread %d I/O num %lu times\n", q_num, i
+                    , io_profiler[i].getIONum());
+            
+            io_profiler[i].clear();
+        }
+
+        q_num++;
+
+        hashtable->bucketclear(0, 1);
+        hashtable->destroy();
+        delete hashtable;
+        delete query;
+       
+        numaclearlookaside(); 
+        //system("free -m");
+        //break;
+    }
+
+    cout << "Total time " << total.getTime() << " seconds" << endl;
+    
+    qfile.close();
+    delete index;
+    //delete[] clear_buf;
+
+    return 0;
+}
+
+void select(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable){
+
+    int buffsize = 1024*1024;
+    int nbuckets = 16*1024*1024;
+    int tuplesperbucket = 2;
+    //int nbuckets = 100*1024*1024;
+    //int tuplesperbucket = 1;
+    
+    Query query;
+    Config cfg;
+
+    cfg.getRoot().add("path", Setting::TypeString) = datadir;
+    cfg.getRoot().add("buffsize", Setting::TypeInt) = buffsize;
+    
+    Setting& filternode = cfg.getRoot().add("filterop"
+            , Setting::TypeGroup); 
+    {
+        filternode.add("query", Setting::TypeInt64) = (int64_t) q;
+        filternode.add("hashtable", Setting::TypeInt64) = 
+                                            (int64_t) hashtable;
+
+        Setting& hashfuncnode = filternode.add("hash"
+                , Setting::TypeGroup);
+        hashfuncnode.add("fn", Setting::TypeString) = "modulo";
+        hashfuncnode.add("buckets", Setting::TypeInt) = nbuckets;
+        filternode.add("tuplesperbucket", Setting::TypeInt) = 
+                                                    tuplesperbucket;
+        filternode.add("allocpolicy", Setting::TypeString) = "striped";
+
+        filternode.add("threadnum", Setting::TypeInt) = threadnum;
+        
+        //find all partitions
+        vector<int> sel_attrs = q->getSelection();
+        set<int> sel_parts = index->getPartitionByAttr(sel_attrs); 
+        Setting& files = filternode.add("files", Setting::TypeArray);
+        for(const auto i : sel_parts)
+            files.add(Setting::TypeInt) = i;
+
+    }
+
+    Setting& mergenode = cfg.getRoot().add("merge", Setting::TypeGroup);
+    {
+        mergenode.add("threads", Setting::TypeInt) = threadnum;
+    }
+
+    MergeOp node1;
+    FilterHVLockFreeOp node2;
+
+    query.tree = &node1;
+    node1.nextOp = &node2;
+
+    node1.init(cfg, mergenode);
+    node2.init(cfg, filternode);
+
+    query.threadInit();
+    if (query.scanStart() != Operator::Ready) {
+        fail("Scan initialization failed.");
+    }
+    Operator::GetNextResultT result;
+    while(result.first == Operator::Ready){
+        result = query.getNext();
+    }
+    assert(result.first != Operator::Error);
+
+    if (query.scanStop() != Operator::Ready) {
+        fail("Scan stop failed.");
+    }
+
+    query.threadClose();
+    query.destroynofree();
+
+}
+
+void project(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable){
+    
+    int buffsize = 1024*1024;
+    int nbuckets = hashtable->getNumberOfBuckets();
+    
+    Query query;
+    Config cfg;
+    
+    cfg.getRoot().add("path", Setting::TypeString) = datadir;
+    cfg.getRoot().add("buffsize", Setting::TypeInt) = buffsize;
+
+    Setting& projnode = cfg.getRoot().add("projop", Setting::TypeGroup);
+    {
+
+        projnode.add("query", Setting::TypeInt64) = (int64_t) q;
+        projnode.add("hashtable", Setting::TypeInt64) = 
+                                            (int64_t) hashtable;
+        projnode.add("index", Setting::TypeInt64) = (int64_t) index;
+        projnode.add("threadnum", Setting::TypeInt) = threadnum;
+        
+        Setting& hashfuncnode = projnode.add("hash"
+                , Setting::TypeGroup);
+        hashfuncnode.add("fn", Setting::TypeString) = "modulo";
+        hashfuncnode.add("buckets", Setting::TypeInt) = nbuckets;
+    }
+    
+    Setting& mergenode = cfg.getRoot().add("merge", Setting::TypeGroup);
+    {
+        mergenode.add("threads", Setting::TypeInt) = threadnum;
+    }
+
+    MergeOp node1;
+    ProjectHVLockFreeOp node2;
+
+    query.tree = &node1;
+    node1.nextOp = &node2;
+
+    node1.init(cfg, mergenode);
+    node2.init(cfg, projnode);
+
+    query.threadInit();
+    if (query.scanStart() != Operator::Ready) {
+        fail("Scan initialization failed.");
+    }
+    Operator::GetNextResultT result;
+    while(result.first == Operator::Ready){
+        result = query.getNext();
+    }
+    assert(result.first != Operator::Error);
+
+    if (query.scanStop() != Operator::Ready) {
+        fail("Scan stop failed.");
+    }
+
+    query.threadClose();
+    query.destroynofree();
+}
+
+
+void evaluate_direct(PQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret){
+
+    ret.clear();
+
+    ifstream ifile(data_path, ios::binary);
+    uint64_t btnum = 1024*1024;
+    uint64_t btsize = btnum * ANUM;
+    VTYPE* buffer = new VTYPE[btsize];
+    uint64_t tnum = 0;
+
+    vector<VTYPE> tmp;
+    do{
+      ifile.read((char*) buffer, btsize * sizeof(VTYPE));
+      uint64_t len = ifile.gcount();
+      if(len % (sizeof(VTYPE)*ANUM) != 0){
+          delete[] buffer;
+          ifile.close();
+      }
+      len = len / sizeof(VTYPE) / ANUM;
+
+      vector<uint64_t> tids;
+      query->evaluate(buffer, len, tmp, tids);
+
+      /*for(auto i : tids)
+          printf("%lu\n", i + tnum);*/
+
+      ret.insert(ret.end(), tmp.begin(), tmp.end());
+      tnum += len;
+    }while(tnum < TNUM);
+
+    delete[] buffer;
+    ifile.close();
+}
+
+bool compare_random(HashTableD* hashtable, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num){
+    uint64_t nbucket = hashtable->getNumberOfBuckets();
+    HashTable::Iterator it = hashtable->createIterator();
+    void* tuple;
+    VTYPE* tup_data;
+    
+    uint64_t tnum = 0;
+    for(uint64_t i = 0; i < nbucket; i++){
+        hashtable->placeIterator(it, i);
+        while((tuple = it.next())){
+            tnum++;
+            tup_data = (VTYPE*)((char*)tuple + sizeof(uint64_t));
+            for(int j = 0; j < proj_num; j++)
+                if(tup_data[j] == INVALID_VALUE)
+                    return false;
+        }
+    }
+
+    printf("%lu, %lu\n", tnum, ret_direct.size() / proj_num);
+
+    if(tnum != ret_direct.size() / proj_num)
+        return false;
+
+    uint64_t checked_tnum = 0;
+    for(uint64_t i = 0; i < num || checked_tnum < num; i++){
+        uint64_t b = rand() % nbucket;
+        hashtable->placeIterator(it, b);
+        while((tuple = it.next())){
+            tup_data = (VTYPE*)((char*)tuple + sizeof(uint64_t));
+            bool exist = false;
+            for(uint64_t j = 0; j < ret_direct.size() && !exist
+                    ; j+= proj_num){
+                bool eq = true;
+                for(int k = 0; k < proj_num && eq; k++)
+                    if(tup_data[k] != ret_direct[j + k])
+                        eq = false;
+                if(eq)
+                    exist = true;
+            }
+            if(!exist)
+                return false;
+            checked_tnum++;
+        }
+    }
+    cout << "checked " << checked_tnum << " tuples" << endl;
+    return true;
+}
diff --git a/drivers/partitions/executequery-hv-seq.cpp b/drivers/partitions/executequery-hv-seq.cpp
new file mode 100644
index 0000000..404328f
--- /dev/null
+++ b/drivers/partitions/executequery-hv-seq.cpp
@@ -0,0 +1,403 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <cstring>
+#include <cstdint>
+#include <vector>
+#include "libconfig.h++"
+
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/partitionquery.h"
+#include "../../util/partitions/index.h"
+#include "../../util/partitions/hashtabledelete.h"
+#include "../../util/partitions/readdummy.h"
+#include "../../util/partitions/profiler.h"
+
+#include "../../query.h"
+#include "../../operators/operators.h"
+#include "../../visitors/allvisitors.h"
+//#include "../../rdtsc.h"
+#include "../../operators/partitions/filterhv-seq.h"
+#include "../../operators/partitions/projecthv-seq.h"
+
+using namespace std;
+using namespace libconfig;
+
+#ifdef PERF
+#include "../../util/partitions/profiler_trace.h"
+ProfilerTrace trace;
+#endif
+
+extern Profiler io_profiler[128];
+
+void fail(const char* explanation) {
+    std::cout << " ** FAILED: " << explanation << std::endl;
+    throw QueryExecutionError();
+}
+
+void select(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable);
+void project(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable);
+
+void evaluate_direct(PQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret);
+bool compare_random(HashTableD* hashtable, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num);
+
+int main(const int argc, const char* argv[]){
+    bool flush = false;
+    if (argc == 6)
+        flush = true;
+    string qpath = argv[1];
+    string datadir = argv[2];
+    string indexpath = argv[3];
+    int threadnum = atoi(argv[4]);
+    // string orgpath = argv[5];
+
+    /*
+    string clear_cache_file = argv[5];
+    int clear_file_num = atoi(argv[6]);
+    uint64_t clear_buf_size = 1024*1024*1024;
+    //char* clear_buf = new char[clear_buf_size];
+    */
+    //string clear_cache_path = argv[5];
+
+    Index* index = Index::deserialize(indexpath);
+    ifstream qfile(qpath.c_str());
+    string qstr;
+   
+#ifdef PERF
+    trace.init(threadnum);
+#endif
+
+    Profiler total;
+    int q_num = 0;
+    while(getline(qfile, qstr)){
+        system("free -m");
+        Profiler one_query_time;
+        
+        if (flush)
+        {
+            string clear_cache_path = argv[5];
+            system(clear_cache_path.c_str());
+        }
+        system("free -m");
+        
+        PQuery<VTYPE>* query = PQuery<VTYPE>::parse_string(qstr);
+        HashTableD* hashtable = new HashTableD();
+
+        one_query_time.start_timer();
+        total.start_timer();
+
+#ifdef PERF
+        trace.clear();
+        trace.add(0, "start select");
+#endif
+
+        select(query, index, datadir, threadnum, hashtable);
+
+#ifdef PERF
+        trace.add(0, "end select");
+        trace.add(0, "start project");
+#endif
+
+        project(query, index, datadir, threadnum, hashtable);
+
+
+        one_query_time.stop_timer();
+        total.stop_timer();
+
+#ifdef PERF
+        trace.add(0, "end project");
+        trace.print();
+#endif
+        /*
+        vector<VTYPE> direct_ret;
+        evaluate_direct(query, orgpath.c_str(), direct_ret);
+        bool eq = compare_random(hashtable, direct_ret
+                , query->projection.count(), 10);
+        if(!eq)
+            fail("Compare not pass");
+        */
+        cout << "query " << q_num << " : " << one_query_time.getTime() << " seconds" << endl;
+        
+        for(int i = 0; i < threadnum; i++){
+            printf("Query %d Thread %d I/O time %f seconds\n", q_num, i
+                    , io_profiler[i].getTime());
+            printf("Query %d Thread %d I/O size %lu bytes\n", q_num, i
+                    , io_profiler[i].getIOSize());
+            printf("Query %d Thread %d I/O num %lu times\n", q_num, i
+                    , io_profiler[i].getIONum());
+            
+            io_profiler[i].clear();
+        }
+        
+        q_num++;
+        
+
+        hashtable->bucketclear(0, 1);
+        hashtable->destroy();
+        delete hashtable;
+        delete query;
+        
+        numaclearlookaside(); 
+        //system("free -m");
+        //break;
+    }
+
+    cout << "Total time " << total.getTime() << " seconds" << endl;
+    
+    qfile.close();
+    delete index;
+    //delete[] clear_buf;
+
+    return 0;
+}
+
+void select(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable){
+
+    int buffsize = 1024*1024;
+    int nbuckets = 16*1024*1024;
+    int tuplesperbucket = 2;
+    //int nbuckets = 100*1024*1024;
+    //int tuplesperbucket = 1;
+    
+    Query query;
+    Config cfg;
+
+    cfg.getRoot().add("path", Setting::TypeString) = datadir;
+    cfg.getRoot().add("buffsize", Setting::TypeInt) = buffsize;
+    
+    Setting& filternode = cfg.getRoot().add("filterop"
+            , Setting::TypeGroup); 
+    {
+        filternode.add("query", Setting::TypeInt64) = (int64_t) q;
+        filternode.add("hashtable", Setting::TypeInt64) = 
+                                            (int64_t) hashtable;
+
+        Setting& hashfuncnode = filternode.add("hash"
+                , Setting::TypeGroup);
+        hashfuncnode.add("fn", Setting::TypeString) = "modulo";
+        hashfuncnode.add("buckets", Setting::TypeInt) = nbuckets;
+        filternode.add("tuplesperbucket", Setting::TypeInt) = 
+                                                    tuplesperbucket;
+        filternode.add("allocpolicy", Setting::TypeString) = "striped";
+
+        filternode.add("threadnum", Setting::TypeInt) = threadnum;
+        
+        //find all partitions
+        vector<int> sel_attrs = q->getSelection();
+        set<int> sel_parts = index->getPartitionByAttr(sel_attrs); 
+        Setting& files = filternode.add("files", Setting::TypeArray);
+        for(const auto i : sel_parts)
+            files.add(Setting::TypeInt) = i;
+
+    }
+
+    Setting& mergenode = cfg.getRoot().add("merge", Setting::TypeGroup);
+    {
+        mergenode.add("threads", Setting::TypeInt) = threadnum;
+    }
+
+    MergeOp node1;
+    FilterHVOp node2;
+
+    query.tree = &node1;
+    node1.nextOp = &node2;
+
+    node1.init(cfg, mergenode);
+    node2.init(cfg, filternode);
+
+    query.threadInit();
+    if (query.scanStart() != Operator::Ready) {
+        fail("Scan initialization failed.");
+    }
+    Operator::GetNextResultT result;
+    while(result.first == Operator::Ready){
+        result = query.getNext();
+    }
+    assert(result.first != Operator::Error);
+
+    if (query.scanStop() != Operator::Ready) {
+        fail("Scan stop failed.");
+    }
+
+    query.threadClose();
+    query.destroynofree();
+
+}
+
+void project(PQuery<VTYPE>* q, Index* index, string datadir
+        , int threadnum, HashTableD* hashtable){
+    
+    int buffsize = 1024*1024;
+    int nbuckets = hashtable->getNumberOfBuckets();
+    
+    Query query;
+    Config cfg;
+    
+    cfg.getRoot().add("path", Setting::TypeString) = datadir;
+    cfg.getRoot().add("buffsize", Setting::TypeInt) = buffsize;
+
+    Setting& projnode = cfg.getRoot().add("projop", Setting::TypeGroup);
+    {
+
+        projnode.add("query", Setting::TypeInt64) = (int64_t) q;
+        projnode.add("hashtable", Setting::TypeInt64) = 
+                                            (int64_t) hashtable;
+        projnode.add("index", Setting::TypeInt64) = (int64_t) index;
+        projnode.add("threadnum", Setting::TypeInt) = threadnum;
+        
+        Setting& hashfuncnode = projnode.add("hash"
+                , Setting::TypeGroup);
+        hashfuncnode.add("fn", Setting::TypeString) = "modulo";
+        hashfuncnode.add("buckets", Setting::TypeInt) = nbuckets;
+    }
+    
+    Setting& mergenode = cfg.getRoot().add("merge", Setting::TypeGroup);
+    {
+        mergenode.add("threads", Setting::TypeInt) = threadnum;
+    }
+
+    MergeOp node1;
+    ProjectHVOp node2;
+
+    query.tree = &node1;
+    node1.nextOp = &node2;
+
+    node1.init(cfg, mergenode);
+    node2.init(cfg, projnode);
+
+    query.threadInit();
+    if (query.scanStart() != Operator::Ready) {
+        fail("Scan initialization failed.");
+    }
+    Operator::GetNextResultT result;
+    while(result.first == Operator::Ready){
+        result = query.getNext();
+    }
+    assert(result.first != Operator::Error);
+
+    if (query.scanStop() != Operator::Ready) {
+        fail("Scan stop failed.");
+    }
+
+    query.threadClose();
+    query.destroynofree();
+}
+
+
+void evaluate_direct(PQuery<VTYPE>* query, const char* data_path
+        , vector<VTYPE> &ret){
+
+    ret.clear();
+
+    ifstream ifile(data_path, ios::binary);
+    uint64_t btnum = 1024*1024;
+    uint64_t btsize = btnum * ANUM;
+    VTYPE* buffer = new VTYPE[btsize];
+    uint64_t tnum = 0;
+
+    vector<VTYPE> tmp;
+    do{
+      ifile.read((char*) buffer, btsize * sizeof(VTYPE));
+      uint64_t len = ifile.gcount();
+      if(len % (sizeof(VTYPE)*ANUM) != 0){
+          delete[] buffer;
+          ifile.close();
+      }
+      len = len / sizeof(VTYPE) / ANUM;
+
+      vector<uint64_t> tids;
+      query->evaluate(buffer, len, tmp, tids);
+
+      /*for(auto i : tids)
+          printf("%lu\n", i + tnum);*/
+
+      ret.insert(ret.end(), tmp.begin(), tmp.end());
+      tnum += len;
+    }while(tnum < TNUM);
+
+    delete[] buffer;
+    ifile.close();
+}
+
+bool compare_random(HashTableD* hashtable, vector<VTYPE> &ret_direct
+        , int proj_num, uint64_t num){
+    uint64_t nbucket = hashtable->getNumberOfBuckets();
+    HashTable::Iterator it = hashtable->createIterator();
+    void* tuple;
+    VTYPE* tup_data;
+    
+    uint64_t tnum = 0;
+    for(uint64_t i = 0; i < nbucket; i++){
+        hashtable->placeIterator(it, i);
+        while((tuple = it.next())){
+            tnum++;
+            tup_data = (VTYPE*)((char*)tuple + sizeof(uint64_t));
+            for(int j = 0; j < proj_num; j++)
+                if(tup_data[j] == INVALID_VALUE)
+                    return false;
+        }
+    }
+
+    if(tnum != ret_direct.size() / proj_num)
+        return false;
+
+    uint64_t checked_tnum = 0;
+    for(uint64_t i = 0; i < num || checked_tnum < num; i++){
+        uint64_t b = rand() % nbucket;
+        hashtable->placeIterator(it, b);
+        while((tuple = it.next())){
+            tup_data = (VTYPE*)((char*)tuple + sizeof(uint64_t));
+            bool exist = false;
+            for(uint64_t j = 0; j < ret_direct.size() && !exist
+                    ; j+= proj_num){
+                bool eq = true;
+                for(int k = 0; k < proj_num && eq; k++)
+                    if(tup_data[k] != ret_direct[j + k])
+                        eq = false;
+                if(eq)
+                    exist = true;
+            }
+            if(!exist)
+                return false;
+            checked_tnum++;
+        }
+    }
+    cout << "checked " << checked_tnum << " tuples" << endl;
+    return true;
+}
diff --git a/hash.h b/hash.h
index daec5ac..6bc6617 100644
--- a/hash.h
+++ b/hash.h
@@ -120,11 +120,11 @@ class TupleHasher
 			return prettyname;
 		}
 
-	private:
 		TupleHasher(unsigned short of, unsigned short sz, HashFunction* f, const string nm) 
 			: offset(of), size(sz), fn(f), prettyname(nm)
 		{ }
 
+	private:
 		unsigned short offset;
 		unsigned short size;
 		HashFunction* fn;
diff --git a/lock.h b/lock.h
index 8b7a300..ac02e37 100644
--- a/lock.h
+++ b/lock.h
@@ -52,6 +52,16 @@ class Lock {
 			}
 		}
 
+        inline bool trylock(){
+            //if res == 0, the lock is succeed
+            int res = tas(&_l);
+#if defined(__i386__) || defined(__x86_64__)
+            if(res)
+				__asm__ __volatile__ ("pause\n");
+#endif
+            return res == 0;
+        }
+
 		/** Unlocks the lock object. */
 		inline void unlock() 
 		{ 
diff --git a/operators/baselines/column/filtercolumn.cpp b/operators/baselines/column/filtercolumn.cpp
new file mode 100644
index 0000000..042e655
--- /dev/null
+++ b/operators/baselines/column/filtercolumn.cpp
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "filtercolumn.h"
+#include "../../../util/numaasserts.h"
+#include "../../../util/numaallocate.h"
+
+#include <cstdint>
+
+void FilterColumnOp::init(libconfig::Config& root
+        , libconfig::Setting& cfg){
+   
+    Operator::init(root, cfg);
+    libconfig::Setting& ranges = cfg["ranges"];
+    libconfig::Setting& equal = cfg["equal"];
+    for(int i = 0; i < ranges.getLength(); i++){
+        this->ranges.push_back(ranges[i]);
+        this->equal.push_back(equal[i]);
+    }
+
+    anum = ranges.getLength() / 2;
+
+    for(int i = 0; i < MAX_THREADS; i++){
+        output.push_back(NULL);
+        state.push_back(State(NULL, Ready, 0));
+    }
+}
+
+void FilterColumnOp::threadInit(unsigned short threadid){
+    void* space = numaallocate_local("FilterColumn", sizeof(Page), this);
+    output[threadid] =  new(space) Page(buffsize, sizeof(uint64_t)
+            , this);
+    assertaddresslocal(output[threadid]);
+}
+
+void FilterColumnOp::threadClose(unsigned short threadid){
+    if(output[threadid]){
+        numadeallocate(output[threadid]);
+    }
+    output[threadid] = NULL;
+}
+
+/*Operator::ResultCode FilterColumnOp::scanStart(unsigned short threadid
+        , Page* indexdatapage, Schema& indexdataschema){
+    state[threadid] = State(&EmptyPage, Operator::Ready, 0);
+    return nextOp->scanStart(threadid, indexdatapage, indexdataschema);
+}*/
+
+Operator::GetNextResultT FilterColumnOp::getNext(unsigned short threadid){
+    BufferSet* in;
+    Operator::ResultCode rc;
+    unsigned int tupoffset;
+
+    Page* out = output[threadid];
+    out->clear();
+
+    in = state[threadid].input;
+    rc = state[threadid].prevresult;
+    tupoffset = state[threadid].prevoffset;
+
+    while(rc != Error){
+        dbgassert(rc != Error);
+        dbgassert(in != NULL);
+        dbgassert(tupoffset >= 0);
+        
+        void* values[anum];
+
+        while(in != NULL && 
+              (values[0] = in->buffers[0]->getTupleOffset(tupoffset))){
+            for(int i = 1; i < anum; i++)
+                values[i] = in->buffers[i]->getTupleOffset(tupoffset);
+
+            bool pass = true;
+            //compare with ranges
+            for(int i = 0; i < anum && pass; i++){
+                VTYPE v = *(VTYPE*) values[i];
+                
+                VTYPE l(ranges[2*i]), r(ranges[2*i + 1]);
+                if((v < l || (v ==l && !equal[2*i]))
+                   || (v > r || (v == r && !equal[2*i + 1])))
+                    pass = false;
+            }
+            if(pass){
+                void* dest = out->allocateTuple();
+                uint64_t tid = in->tuple_start + tupoffset;
+                *(uint64_t*)dest = tid;
+            }
+            
+            tupoffset ++;
+            
+            if(!out->canStoreTuple()){
+                state[threadid] = State(in, Ready, tupoffset);
+                return std::make_pair(Ready, out);
+            }
+
+        }
+
+        /*if(rc == Finished){
+            state[threadid] = State(&EmptyPage, Finished, 0);
+            return make_pair(Finished, out);
+        }*/
+
+        Operator::GetNextResultT result = nextOp->getNext(threadid);
+        rc = result.first;
+        in = static_cast<BufferSet*>(result.second);
+        tupoffset = 0;
+        
+        if(rc == Finished){
+            state[threadid] = State(&EmptyPage, Finished, 0);
+            return make_pair(Finished, out);
+        }
+    }
+
+    Operator::Page* NullPage = 0;
+
+    state[threadid] = State(NullPage, Error, 0);
+    return make_pair(Error, NullPage);
+}
diff --git a/operators/baselines/column/filtercolumn.h b/operators/baselines/column/filtercolumn.h
new file mode 100644
index 0000000..a987d6e
--- /dev/null
+++ b/operators/baselines/column/filtercolumn.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FILTERCOLUMN__
+#define __FILTERCOLUMN__
+
+#include <vector>
+
+#include "../../operators.h"
+#include "../../operators_priv.h"
+#include "../../../util/partitions/constants.h"
+#include "parallelscancolumn.h"
+
+using namespace std;
+
+class FilterColumnOp: public virtual SingleInputOp{
+public:
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual void threadInit(unsigned short threadid);
+    /*virtual ResultCode scanStart(unsigned short threadid
+            , Page* indexdatapage, Schema& indexdataschema);*/
+    virtual GetNextResultT getNext(unsigned short threadid); 
+    virtual void threadClose(unsigned short threadid);
+
+private:
+
+    typedef ParallelScanColumnOp::TupleBufferSet BufferSet;
+
+    class State{
+        public:
+            State(Page* i, Operator::ResultCode r, unsigned int c)
+                : input(static_cast<BufferSet*>(i))
+                  , prevresult(r), prevoffset(c)
+            { }
+
+            BufferSet* input;
+            Operator::ResultCode prevresult;
+            unsigned int prevoffset;
+    };
+    
+    vector<VTYPE> ranges;
+    vector<bool> equal;
+    vector<Page*> output;
+    vector<State> state;
+    int anum;
+
+};
+
+#endif
diff --git a/operators/baselines/column/parallelscancolumn.cpp b/operators/baselines/column/parallelscancolumn.cpp
new file mode 100644
index 0000000..0419f8e
--- /dev/null
+++ b/operators/baselines/column/parallelscancolumn.cpp
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "parallelscancolumn.h"
+#include "../../../util/baselines/index.h"
+#include <cstring>
+#include <bitset>
+using namespace std;
+
+void ParallelScanColumnOp::init(libconfig::Config& root
+        , libconfig::Setting& cfg){
+    ZeroInputOp::init(root, cfg);
+    string path = (const char*) root.getRoot()["path"];
+    unsigned long tmp;
+    tmp = cfg["index"];
+    Index* index = (Index*) tmp;
+    int thread_num = cfg["thread_num"];
+    libconfig::Setting& attributes = cfg["attributes"];
+    bitset<ANUM> attrs;
+    for(int i = 0; i < attributes.getLength(); i++){
+        int a = attributes[i];
+        attrs.set(a);
+    }
+    
+    bitset<TNUM>* tids = NULL;
+    if(cfg.exists("tuples")){
+        tmp = cfg["tuples"];
+        tids = (bitset<TNUM>*)tmp; 
+    }
+
+    table = new TableColumn(path, index, thread_num, &attrs, tids);
+    
+    for(int i = 0; i < thread_num; i++){
+        partitions.push_back(vector<Partition<VTYPE>*>());
+        tuple_buffer.push_back(vector<TupleBuffer*>());
+    }
+
+}
+
+
+Operator::ResultCode ParallelScanColumnOp::scanStop(
+        unsigned short threadid){
+    for(int i = 0; i < partitions[threadid].size(); i++){
+        delete partitions[threadid][i];
+        delete tuple_buffer[threadid][i];
+    }
+
+
+    return Ready;
+}
+
+
+Operator::GetNextResultT 
+    ParallelScanColumnOp::getNext(unsigned short threadid){
+
+    for(int i = 0; i < partitions[threadid].size(); i++){
+        delete partitions[threadid][i];
+        delete tuple_buffer[threadid][i];
+    }
+    partitions[threadid].clear();
+    tuple_buffer[threadid].clear();
+    uint64_t row_off;
+
+    bool ret = table->atomicGetNext(threadid, partitions[threadid]
+            , row_off);
+    if(!ret){
+        return std::make_pair(Operator::Finished, &EmptyPage);
+    }else{
+        for(int i = 0; i < partitions[threadid].size(); i++){
+            uint64_t len, tuplesize;
+            void* data = (void*) partitions[threadid][i]->getAllData(len
+                    , tuplesize);
+            TupleBuffer* buf = new TupleBuffer(data, len, NULL
+                    , tuplesize);
+            tuple_buffer[threadid].push_back(buf);
+        }
+
+        TupleBufferSet* ret = new TupleBufferSet();
+        ret->buffers = tuple_buffer[threadid];
+        ret->tuple_start = row_off;
+        return std::make_pair(Operator::Ready, (Page*)ret);
+    }
+
+}
diff --git a/operators/baselines/column/parallelscancolumn.h b/operators/baselines/column/parallelscancolumn.h
new file mode 100644
index 0000000..17cd2c4
--- /dev/null
+++ b/operators/baselines/column/parallelscancolumn.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PARALLELSCANCOLUMN__
+#define __PARALLELSCANCOLUMN__
+
+#include <vector>
+#include <cstdint>
+
+#include "../../operators.h"
+#include "../../operators_priv.h"
+#include "../../../util/baselines/tablecolumn.h"
+
+using namespace std;
+
+
+class ParallelScanColumnOp: public virtual ZeroInputOp{
+
+public:
+
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual GetNextResultT getNext(unsigned short threadid);
+    virtual void destroy() {delete table;}
+    virtual ResultCode scanStop(unsigned short threadid);
+    //virtual void accept(Visitor* v) {v->visit(this);}
+
+    class TupleBufferSet: public TupleBuffer{
+        public:
+            TupleBufferSet(): TupleBuffer(4, 4, NULL) 
+                {}
+            vector<TupleBuffer*> buffers;
+            uint64_t tuple_start;
+    };
+
+private:
+
+    vector<vector<Partition<VTYPE>*>> partitions;
+    vector<vector<TupleBuffer*>> tuple_buffer;
+
+    TableColumn *table;
+
+};
+
+#endif
diff --git a/operators/baselines/column/projectcolumn.cpp b/operators/baselines/column/projectcolumn.cpp
new file mode 100644
index 0000000..de9fce0
--- /dev/null
+++ b/operators/baselines/column/projectcolumn.cpp
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "projectcolumn.h"
+#include "../../../util/numaasserts.h"
+#include "../../../util/numaallocate.h"
+
+#include <cstdint>
+
+void ProjectColumnOp::init(libconfig::Config& root
+        , libconfig::Setting& cfg){
+   
+    Operator::init(root, cfg);
+   
+    unsigned long tmp = cfg["tuples"];
+    tuples = (bitset<TNUM>*) tmp;
+    anum = cfg["attribute_num"];
+
+    for(int i = 0; i < MAX_THREADS; i++){
+        output.push_back(NULL);
+        state.push_back(State(NULL, Ready, 0));
+    }
+}
+
+void ProjectColumnOp::threadInit(unsigned short threadid){
+    void* space = numaallocate_local("ProjectColumn", sizeof(Page), this);
+    output[threadid] =  new(space) Page(buffsize, sizeof(VTYPE) * anum
+            , this);
+    assertaddresslocal(output[threadid]);
+}
+
+
+void ProjectColumnOp::threadClose(unsigned short threadid){
+    if(output[threadid]){
+        numadeallocate(output[threadid]);
+    }
+    output[threadid] = NULL;
+}
+
+/*Operator::ResultCode ProjectColumnOp::scanStart(unsigned short threadid
+        , Page* indexdatapage, Schema& indexdataschema){
+    state[threadid] = State(&EmptyPage, Operator::Ready, 0);
+    return nextOp->scanStart(threadid, indexdatapage, indexdataschema);
+}*/
+
+Operator::GetNextResultT ProjectColumnOp::getNext(unsigned short threadid){
+    Operator::Page* NullPage = 0;
+    
+    BufferSet* in;
+    Operator::ResultCode rc;
+    unsigned int tupoffset;
+
+    Page* out = output[threadid];
+    out->clear();
+
+    in = state[threadid].input;
+    rc = state[threadid].prevresult;
+    tupoffset = state[threadid].prevoffset;
+
+
+
+    while(rc != Error){
+        dbgassert(rc != Error);
+        dbgassert(in != NULL);
+        dbgassert(tupoffset >= 0);
+        
+        if(in != NULL){
+            uint64_t start = in->tuple_start;
+            uint64_t end = start + in->buffers[0]->getNumTuples();
+            void* values[anum];
+
+            while(tupoffset + start < end){
+                if(!tuples->test(tupoffset + start)){
+                    tupoffset++;
+                    continue;
+                }
+                
+                VTYPE* dest = (VTYPE*)out->allocateTuple();
+
+                for(int i = 0; i < anum; i++)
+                    dest[i] = *((VTYPE*)in->buffers[i]->getTupleOffset(tupoffset));
+                tupoffset++;
+                if(!out->canStoreTuple()){
+                    state[threadid] = State(in, Ready, tupoffset);
+                    return std::make_pair(Ready, out);
+                }
+            }
+
+        }
+        
+        Operator::GetNextResultT result = nextOp->getNext(threadid);
+        rc = result.first;
+        in = static_cast<BufferSet*>(result.second);
+        tupoffset = 0;
+        
+        if(rc == Finished){
+            state[threadid] = State(NullPage, Finished, 0);
+            return std::make_pair(Finished, out);
+        }
+    }
+    
+
+    state[threadid] = State(NullPage, Error, 0);
+    return make_pair(Error, NullPage);
+}
diff --git a/operators/baselines/column/projectcolumn.h b/operators/baselines/column/projectcolumn.h
new file mode 100644
index 0000000..a6976b4
--- /dev/null
+++ b/operators/baselines/column/projectcolumn.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PROJECTCOLUMN__
+#define __PROJECTCOLUMN__
+
+#include <vector>
+#include <bitset>
+
+#include "../../operators.h"
+#include "../../operators_priv.h"
+#include "../../../util/partitions/constants.h"
+#include "parallelscancolumn.h"
+
+using namespace std;
+
+class ProjectColumnOp: public virtual SingleInputOp{
+
+public:
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual void threadInit(unsigned short threadid);
+    /*virtual ResultCode scanStart(unsigned short threadid
+            , Page* indexdatapage, Schema& indexdataschema);*/
+    virtual GetNextResultT getNext(unsigned short threadid); 
+    virtual void threadClose(unsigned short threadid);
+
+private:
+    typedef ParallelScanColumnOp::TupleBufferSet BufferSet;
+    
+    class State{
+        public:
+            State(Page* i, Operator::ResultCode r, unsigned int c)
+                : input(static_cast<BufferSet*>(i))
+                  , prevresult(r), prevoffset(c)
+            { }
+
+            BufferSet* input;
+            Operator::ResultCode prevresult;
+            unsigned int prevoffset;
+    };
+    
+    bitset<TNUM>* tuples;
+    int anum;
+    vector<Page*> output;
+    vector<State> state;
+
+};
+
+#endif
diff --git a/operators/baselines/row/filterrow.cpp b/operators/baselines/row/filterrow.cpp
new file mode 100644
index 0000000..764b24e
--- /dev/null
+++ b/operators/baselines/row/filterrow.cpp
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "filterrow.h"
+#include "../../../util/numaasserts.h"
+#include "../../../util/numaallocate.h"
+#include <iostream>
+
+void FilterRowOp::init(libconfig::Config& root
+        , libconfig::Setting& cfg){
+    Operator::init(root, cfg);
+    libconfig::Setting& ranges = cfg["ranges"];
+    libconfig::Setting& equal = cfg["equal"];
+
+    for(int i = 0; i < ranges.getLength(); i++){
+        this->ranges.push_back(ranges[i]);
+        this->equal.push_back(equal[i]);
+    }
+
+    libconfig::Setting& attr = cfg["attributes"];
+    for(int i = 0; i < attr.getLength(); i++)
+        this->attr.push_back(attr[i]);
+
+    for(int i = 0; i < MAX_THREADS; i++){
+        output.push_back(NULL);
+        state.push_back(State(NULL, Ready, 0));
+    }
+
+    anum = cfg["attribute_per_tuple"];
+
+}
+
+void FilterRowOp::threadInit(unsigned short threadid){
+    void* space = numaallocate_local("FilterRow", sizeof(Page), this);
+    output[threadid] =  new(space) Page(buffsize, sizeof(VTYPE)*anum
+            , this);
+    assertaddresslocal(output[threadid]);
+
+}
+
+Operator::ResultCode FilterRowOp::scanStart(unsigned short threadid
+            , Page* indexdatapage, Schema& indexdataschema){
+    state[threadid] = State(&EmptyPage, Operator::Ready, 0);
+    return nextOp->scanStart(threadid, indexdatapage, indexdataschema);
+}
+
+void FilterRowOp::threadClose(unsigned short threadid){
+    if(output[threadid]){
+        numadeallocate(output[threadid]);
+    }
+    output[threadid] = NULL;
+
+    /*cout << "FilterRow processed " << processed_row_num << " tuples"
+        << endl;
+    cout << "FilterRow passed " << passed_row << " tuples"
+        << endl;*/
+}
+
+Operator::GetNextResultT FilterRowOp::getNext(unsigned short threadid){
+    Page* in;
+    Operator::ResultCode rc;
+    unsigned int tupoffset;
+
+    Page* out = output[threadid];
+    out->clear();
+
+    in = state[threadid].input;
+    rc = state[threadid].prevresult;
+    tupoffset = state[threadid].prevoffset;
+
+    while(rc != Error){
+        dbgassert(rc != Error);
+        dbgassert(in != NULL);
+        dbgassert(tupoffset >= 0);
+
+        VTYPE* tuple;
+        while((tuple = (int*)in->getTupleOffset(tupoffset++))){
+            //processed_row_num ++;
+            bool pass = true;
+            for(int i = 0; i < attr.size() && pass; i++){
+                VTYPE l(ranges[2*i]), r(ranges[2*i + 1]);
+                VTYPE v = tuple[attr[i]];
+                if(v < l || (v == l && !equal[2*i])
+                        || v > r || (v == r && !equal[2*i + 1]))
+                    pass = false;
+            }
+            if (pass){
+                //passed_row ++;
+                void* dest = out->allocateTuple();
+                memcpy(dest, (void*)tuple, in->getTupleSize());
+            }
+
+            if(!out->canStoreTuple()){
+                state[threadid] = State(in, Ready, tupoffset);
+                return std::make_pair(Ready, out);
+            }
+        }
+        
+        if(rc == Finished){
+            state[threadid] = State(&EmptyPage, Finished, 0);
+            return make_pair(Finished, out);
+        }
+        
+        Operator::GetNextResultT result = nextOp->getNext(threadid);
+        rc = result.first;
+        in = result.second;
+        tupoffset = 0;
+    }
+    
+    Operator::Page* NullPage = 0;
+
+    state[threadid] = State(NullPage, Error, 0);
+    return make_pair(Error, NullPage);
+}
diff --git a/operators/baselines/row/filterrow.h b/operators/baselines/row/filterrow.h
new file mode 100644
index 0000000..1e8e0a6
--- /dev/null
+++ b/operators/baselines/row/filterrow.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FILTERROW__
+#define __FILTERROW__
+
+#include "../../operators.h"
+#include "../../operators_priv.h"
+#include "../../../util/partitions/constants.h"
+
+#include <vector>
+
+using namespace std;
+
+class FilterRowOp: public virtual SingleInputOp{
+public:
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual void threadInit(unsigned short threadid);
+    virtual ResultCode scanStart(unsigned short threadid
+            , Page* indexdatapage, Schema& indexdataschema);
+    virtual GetNextResultT getNext(unsigned short threadid); 
+    virtual void threadClose(unsigned short threadid);
+private:
+    class State{
+        public:
+            State(Page* i, Operator::ResultCode r, unsigned int c)
+                : input(i), prevresult(r), prevoffset(c)
+            { }
+
+            Page* input;
+            Operator::ResultCode prevresult;
+            unsigned int prevoffset;
+    };
+    
+    vector<Page*> output;
+    vector<State> state;
+    vector<VTYPE> ranges;
+    vector<bool> equal;
+    int anum;
+
+    vector<int> attr;
+
+    //uint64_t processed_row_num = 0;
+    //uint64_t passed_row = 0;
+};
+
+#endif
diff --git a/operators/baselines/row/parallelscanrow.cpp b/operators/baselines/row/parallelscanrow.cpp
new file mode 100644
index 0000000..f2c35f6
--- /dev/null
+++ b/operators/baselines/row/parallelscanrow.cpp
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "parallelscanrow.h"
+#include "../../../util/numaasserts.h"
+#include "../../../util/numaallocate.h"
+
+
+void ParallelScanRowOp::init(libconfig::Config& root
+        , libconfig::Setting& cfg){
+    ZeroInputOp::init(root, cfg);
+    string path = (const char*) root.getRoot()["path"];
+    unsigned long tmp;
+    tmp = cfg["index"];
+    Index* index = (Index*) tmp;
+    int thread_num = cfg["thread_num"];
+    libconfig::Setting& attributes = cfg["attributes"];
+    
+    for(int i = 0; i < attributes.getLength(); i++){
+        int a = attributes[i];
+        attrs.set(a);
+        attrs_v.push_back(a);
+    }
+
+    table = new TableRow(path, index, thread_num, &attrs);
+    table->getColumnOff(schema_poff, schema_voff);
+
+    for(int i = 0; i < thread_num; i++)
+        out.push_back(NULL);
+
+    /*//set the output schema, which stores all attributes in the selection 
+    //and projection
+    ColumnType ctype = CT_INTEGER;
+    if(typeid(VTYPE) == typeid(float))
+        ctype = CT_FLOAT;
+
+    schema = Schema();
+    for(int i = 0; i < attrs_v.size(); i++)
+        schema.add(ctype);
+    */
+}
+
+
+void ParallelScanRowOp::threadInit(unsigned short threadid){
+    void* space = numaallocate_local("ParallelScanRow", sizeof(Page)
+            , this);
+    int attr_num = attrs.count();
+    int tuple_in_out = TableRow::tuples_per_next;
+    out[threadid] =  new(space) Page(attr_num*tuple_in_out*sizeof(VTYPE)
+            , attr_num * sizeof(VTYPE), this);
+    assertaddresslocal(out[threadid]);
+}
+
+void ParallelScanRowOp::threadClose(unsigned short threadid){
+    if(out[threadid] != NULL)
+        numadeallocate(out[threadid]);
+    out[threadid] = NULL;
+}
+
+Operator::GetNextResultT ParallelScanRowOp::getNext(
+        unsigned short threadid){
+    /*if(out[threadid] != NULL){
+        numadeallocate(out[threadid]);
+        out[threadid] = NULL;
+    }*/
+    out[threadid]->clear();
+    uint64_t row_num;
+    TableRow::SubTable* ret = table->atomicGetNext(threadid, row_num);
+    if(ret == 0)
+        return std::make_pair(Operator::Finished, &EmptyPage);
+    else{
+        /*int attr_num = attrs.count();
+        void* space = numaallocate_local("ParallelScanRow"
+                , sizeof(Page), this);
+        out[threadid] = new(space) Page(attr_num * row_num * sizeof(VTYPE)
+                , attr_num * sizeof(VTYPE), this);*/
+
+        vector<Partition<VTYPE>*> part;
+        vector<uint64_t> off;
+        for(int i = 0; i < row_num; i++){
+            VTYPE* dset = (VTYPE*)out[threadid]->allocateTuple();
+            ret->getNext(part, off);
+            for(int j = 0; j < attrs_v.size(); j++){
+                dset[j] = part[schema_poff[j]]->getData(attrs_v[j]
+                        , off[schema_poff[j]]);
+            }
+        }
+
+        delete ret;
+        return std::make_pair(Operator::Ready, (Page*) out[threadid]);
+    }
+}
diff --git a/operators/baselines/row/parallelscanrow.h b/operators/baselines/row/parallelscanrow.h
new file mode 100644
index 0000000..236c8c9
--- /dev/null
+++ b/operators/baselines/row/parallelscanrow.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PARALLELSCANROW__
+#define __PARALLELSCANROW__
+
+#include "../../operators.h"
+#include "../../operators_priv.h"
+#include "../../../util/baselines/tablerow.h"
+
+#include <bitset>
+#include <vector>
+
+using namespace std;
+
+class ParallelScanRowOp: public virtual ZeroInputOp{
+public:
+
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual GetNextResultT getNext(unsigned short threadid);
+    virtual void destroy() {delete table;}
+    virtual void threadClose(unsigned short threadid);
+    virtual void threadInit(unsigned short threadid);
+private:
+    bitset<ANUM> attrs;
+    vector<int> attrs_v;
+    TableRow* table;
+    vector<int> schema_poff, schema_voff;
+    vector<TupleBuffer*> out;
+};
+
+#endif
diff --git a/operators/baselines/row/projectrow.cpp b/operators/baselines/row/projectrow.cpp
new file mode 100644
index 0000000..c1cc376
--- /dev/null
+++ b/operators/baselines/row/projectrow.cpp
@@ -0,0 +1,126 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "projectrow.h"
+#include "../../../util/numaasserts.h"
+#include "../../../util/numaallocate.h"
+#include "../../../util/partitions/constants.h"
+
+#include <iostream>
+
+void ProjectRowOp::init(libconfig::Config& root
+        , libconfig::Setting& cfg){
+   
+    Operator::init(root, cfg);
+   
+    libconfig::Setting& attr = cfg["attributes"];
+    for(int i = 0; i < attr.getLength(); i++)
+        this->attr.push_back((int)attr[i]);
+
+    for(int i = 0; i < MAX_THREADS; i++){
+        output.push_back(NULL);
+        state.push_back(State(NULL, Ready, 0));
+    }
+}
+
+void ProjectRowOp::threadInit(unsigned short threadid){
+    void* space = numaallocate_local("ProjectRow", sizeof(Page), this);
+    output[threadid] =  new(space) Page(buffsize
+            , sizeof(VTYPE) * attr.size(), this);
+    assertaddresslocal(output[threadid]);
+}
+
+
+void ProjectRowOp::threadClose(unsigned short threadid){
+    if(output[threadid]){
+        numadeallocate(output[threadid]);
+    }
+    output[threadid] = NULL;
+
+    /*cout << "ProjectRow processed " << processed_row_num << " tuples"
+        << endl;*/
+}
+
+Operator::ResultCode ProjectRowOp::scanStart(unsigned short threadid
+            , Page* indexdatapage, Schema& indexdataschema){
+    state[threadid] = State(&EmptyPage, Operator::Ready, 0);
+    return nextOp->scanStart(threadid, indexdatapage, indexdataschema);
+}
+
+Operator::GetNextResultT ProjectRowOp::getNext(unsigned short threadid){
+    Page* in;
+    Operator::ResultCode rc;
+    unsigned int tupoffset;
+
+    Page* out = output[threadid];
+    out->clear();
+
+    in = state[threadid].input;
+    rc = state[threadid].prevresult;
+    tupoffset = state[threadid].prevoffset;
+
+    while(rc != Error){
+        dbgassert(rc != Error);
+        dbgassert(in != NULL);
+        dbgassert(tupoffset >= 0);
+
+        VTYPE* tuple;
+        while(in != NULL &&
+                (tuple = (VTYPE*)in->getTupleOffset(tupoffset++))){
+            
+            //processed_row_num++;
+            void* dest = out->allocateTuple();
+            for(int i = 0; i < attr.size(); i++)
+                ((VTYPE*)dest)[i] = tuple[attr[i]];
+
+            if(!out->canStoreTuple()){
+                state[threadid] = State(in, Ready, tupoffset);
+                return std::make_pair(Ready, out);
+            }
+        }
+        
+        if(rc == Finished){
+            state[threadid] = State(&EmptyPage, Finished, 0);
+            return make_pair(Finished, out);
+        }
+        
+        Operator::GetNextResultT result = nextOp->getNext(threadid);
+        rc = result.first;
+        in = result.second;
+        tupoffset = 0;
+    }
+    
+    Operator::Page* NullPage = 0;
+
+    state[threadid] = State(NullPage, Error, 0);
+    return make_pair(Error, NullPage);
+}
diff --git a/operators/baselines/row/projectrow.h b/operators/baselines/row/projectrow.h
new file mode 100644
index 0000000..b0b86b0
--- /dev/null
+++ b/operators/baselines/row/projectrow.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PROJECTROW__
+#define __PROJECTROW__
+
+#include "../../operators.h"
+#include "../../operators_priv.h"
+
+#include <vector>
+using namespace std;
+
+class ProjectRowOp: public virtual SingleInputOp{
+
+public:
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual void threadInit(unsigned short threadid);
+    virtual ResultCode scanStart(unsigned short threadid
+            , Page* indexdatapage, Schema& indexdataschema);
+    virtual GetNextResultT getNext(unsigned short threadid); 
+    virtual void threadClose(unsigned short threadid);
+private:
+    class State{
+        public:
+            State(Page* i, Operator::ResultCode r, unsigned int c)
+                : input(i), prevresult(r), prevoffset(c)
+            { }
+
+            Page* input;
+            Operator::ResultCode prevresult;
+            unsigned int prevoffset;
+    };
+
+    vector<Page*> output;
+    vector<State> state;
+
+    vector<int> attr;
+
+    //uint64_t processed_row_num = 0;
+};
+
+#endif
diff --git a/operators/operators_priv.h b/operators/operators_priv.h
index 5c3e48f..f41ac0c 100644
--- a/operators/operators_priv.h
+++ b/operators/operators_priv.h
@@ -31,4 +31,9 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#ifndef __OPERATOR_PRIV__
+#define __OPERATOR_PRIV__
+
 static Operator::Page EmptyPage(static_cast<void*>(0), 0, static_cast<void*>(0), 0);
+
+#endif
diff --git a/operators/partitions/filterhv-lock-free-seq.cpp b/operators/partitions/filterhv-lock-free-seq.cpp
new file mode 100644
index 0000000..a9472a5
--- /dev/null
+++ b/operators/partitions/filterhv-lock-free-seq.cpp
@@ -0,0 +1,448 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifdef ENABLE_NUMA
+#define NUMA_VERSION1_COMPATIBILITY //< v1 is widely available 
+#include <numa.h>
+#endif
+
+#include "filterhv-lock-free-seq.h"
+#include "../../util/numaallocate.h"
+#include "../../util/atomics.h"
+#include "../../util/partitions/segment.h"
+
+#include <sstream>
+#include <iostream>
+#include <sys/time.h>
+#include <algorithm>
+
+using std::cerr;
+
+#ifdef PERF
+#include "../../util/partitions/profiler_trace.h"
+extern ProfilerTrace trace;
+
+//operations
+//  start I/O, end I/O
+//  start sync, end sync
+//  start process, end process 
+#endif
+
+bool assert_begin = false;
+
+void FilterHVLockFreeOp::init(libconfig::Config& root
+        , libconfig::Setting& node){
+    assert_begin = false;
+    Operator::init(root, node);
+    data_dir = (const char*) root.getRoot()["path"];
+
+    unsigned long tmp;
+    tmp = node["query"];
+    query = (PQuery<VTYPE>*)tmp;
+    tmp = node["hashtable"];
+    hashtable = (HashTableD*) tmp;
+
+    ostringstream oss;
+    int buckets = node["hash"]["buckets"];
+    
+    _log_buckets = getlogarithm(buckets);
+    buckets = 1 << _log_buckets;
+
+    printf("buckets %d, log %d\n", buckets, _log_buckets);
+
+    //oss << "fn=range" << ", buckets= " << buckets 
+    //    << ", offset=0, size=" << sizeof(uint64_t);
+    //HashFunction* hashfn = new RangeValueHasher(0, TNUM - 1, buckets);
+    //hasher = TupleHasher(0, 8, hashfn, oss.str());
+    //TupleHasher hasher = TupleHasher(0, 8, hashfn, oss.str());
+    //_hash_mask = hasher.buckets() - 1;
+
+    int bucketsize = node["tuplesperbucket"];
+    int hash_tuple_size = sizeof(VTYPE) * query->projection.count()
+        + sizeof(uint64_t);
+    bucketsize *= hash_tuple_size;
+
+	string policystr = node["allocpolicy"];
+    
+    vector<char> allocpolicy;
+	if (policystr == "striped")
+	{
+#ifdef ENABLE_NUMA
+		int maxnuma = numa_max_node() + 1;
+		if (node.exists("stripeon"))
+		{
+			// Stripe data on user-specified NUMA nodes.
+			//
+			libconfig::Setting& stripenode = node["stripeon"];
+			for (int i=0; i<stripenode.getLength(); ++i)
+			{
+				int v = stripenode[i];
+				assert(0 <= v);
+				assert(v < maxnuma);
+				allocpolicy.push_back(static_cast<char>(v));
+			}
+		}
+		else
+		{
+			// No constraint specified, stripe on all NUMA nodes.
+			//
+			for (char i=0; i<maxnuma; ++i)
+			{
+				allocpolicy.push_back(i);
+			}
+		}
+#else
+		cerr << " ** NUMA POLICY WARNING: Memory policy is ignored, "
+			<< "NUMA disabled at compile." << endl;
+#endif
+	}
+  
+    hashtable->init(buckets, bucketsize, hash_tuple_size
+            , allocpolicy, this); 
+    //hashtable->init(hasher.buckets(), bucketsize, hash_tuple_size
+    //        , allocpolicy, this);
+
+    //assign partitions to threads
+    this->thread_num = node["threadnum"];
+    this->process_part_num = 0;
+    libconfig::Setting& filegrep = node["files"];
+    for(int i = 0; i < thread_num; i++){
+        workload.push_back(vector<int>());
+        workload_cur.push_back(0);
+        for(int j = i; j < filegrep.getLength(); j += thread_num){
+            int pid = filegrep[j];
+            workload[i].push_back(pid);
+        }
+        
+        if(workload[i].size() > 0)
+            this->process_part_num ++;
+    }
+
+    this->partitions.resize(thread_num, NULL);
+    pthread_barrier_init(&return_barrier, NULL, thread_num);
+    pthread_barrier_init(&process_barrier, NULL, thread_num);
+
+    tuple_status = new Status[TNUM];
+    for(uint64_t i = 0; i < TNUM; i++)
+        tuple_status[i] = NOT_CHECKED;
+}
+
+Operator::GetNextResultT FilterHVLockFreeOp::getNext(unsigned short t){
+    
+    assert_begin = true;
+
+    if(workload_cur[t] >= workload[t].size())
+        partitions[t] = NULL;
+    else{
+#ifdef PERF
+        trace.add(t, "start I/O");
+#endif
+        string filepath = data_dir + "/p_" 
+            + std::to_string(workload[t][workload_cur[t]]);
+        workload_cur[t]++;
+        partitions[t] = Partition<VTYPE>::readFromFile(t
+                , filepath.c_str());
+#ifdef PERF
+        trace.add(t, "end I/O");
+#endif
+    }
+
+
+#ifdef PERF
+    trace.add(t, "start process");
+#endif
+    
+    Operator::ResultCode ret = Operator::Finished;
+    int pnum = 0;
+    bool processed[thread_num];
+    memset(processed, false, thread_num);
+    
+    while(pnum < this->process_part_num){
+        ret = Operator::Ready;
+        for(int i = 0; i < thread_num; i++){
+            if(partitions[i] == NULL || processed[i])
+                continue;
+            //process the partition
+            vector<Segment<VTYPE>> segments;
+            partitions[i]->getSegments(segments);
+            for(auto& s: segments)
+                processSegment(s, t);
+
+            pnum ++;
+            processed[i] = true;
+        }     
+    }
+
+#ifdef PERF
+    trace.add(t, "end process");
+    trace.add(t, "start sync");
+#endif
+
+    pthread_barrier_wait(&process_barrier);
+
+    if(partitions[t] != NULL){
+        delete partitions[t];
+        partitions[t] = NULL;
+    }
+
+    if(t == 0){
+        this->process_part_num = 0;
+        for(int i = 0; i < thread_num; i++)
+            if(workload_cur[i] < workload[i].size())
+                this->process_part_num++;
+    }
+
+    pthread_barrier_wait(&return_barrier);
+
+#ifdef PERF
+    trace.add(t, "end sync");
+#endif
+    
+    return make_pair(ret, &EmptyPage);
+}
+
+
+void FilterHVLockFreeOp::processSegment(Segment<VTYPE> &seg
+        , unsigned short t){
+#ifdef PERF
+    trace.add(t, "start init iterator");
+#endif 
+    uint64_t tuple_num = seg.getTupleNum();
+    
+    bitset<ANUM> cols = seg.getColumns();
+
+    bitset<ANUM> sel_cols = cols & query->selection;
+    bitset<ANUM> proj_cols = cols & query->projection;
+
+    //the offset in the segment and the attribute id
+    vector<int> sel_off_seg, sel_aids;
+    bitsetToOff(cols, sel_cols, sel_off_seg);
+    bitsetToOff(sel_cols, sel_aids);
+
+    //the offset in the segment and in the total projection attributes
+    vector<int> proj_off_seg, proj_off_proj;
+    bitsetToOff(cols, proj_cols, proj_off_seg);
+    bitsetToOff(query->projection, proj_cols, proj_off_proj);
+
+    int sel_count = sel_cols.count();
+    int proj_count = proj_cols.count();
+    int query_proj_count = query->projection.count();
+    VTYPE* sel_data = new VTYPE[sel_count];
+
+    VTYPE* seg_tup;
+    uint64_t tid;
+    unsigned int slot, bucket;
+
+    unsigned int bucket_step = hashtable->getNumberOfBuckets() 
+                                    / thread_num;
+    unsigned int _min_bucket = bucket_step * t;
+    unsigned int _max_bucket = bucket_step * (t+1);
+    if(t == thread_num - 1)
+        _max_bucket = hashtable->getNumberOfBuckets();
+
+    TupleIterator tup_it(&seg, _log_buckets, tuple_status
+            , thread_num, t, _min_bucket, _max_bucket);
+#ifdef PERF
+    trace.add(t, "end init iterator");
+#endif    
+    while((tid = tup_it.getNext(seg_tup, bucket)) != -1){
+        
+        //check the predicates
+        for(int j = 0; j < sel_count; j++)
+            sel_data[j] = seg_tup[sel_off_seg[j]]; 
+        bool pass = query->evaluate(sel_data, sel_aids);
+
+        Status& status = tuple_status[tid];
+        
+        //the tuple does not satify the query and not in the hashtable
+        if(status == NOT_CHECKED && !pass){
+            status = INVALID;
+            continue;
+        }
+
+        //the tuple satisfies the query and already in the hashtable
+        //but does not contain any projected attributes
+        if(status == VALID && pass && proj_count == 0){
+            continue;
+        }
+
+
+        if(pass){
+            appendToHashtable(tid, seg_tup, &proj_off_proj, &proj_off_seg
+                    , query_proj_count, t);
+            status = VALID;
+        } else{
+            void* ht_tuple;
+            findInHashtable(tid, ht_tuple, bucket, slot);
+            hashtable->Delete(bucket, slot);
+            status = INVALID;
+        }
+    }
+
+}
+
+void FilterHVLockFreeOp::bitsetToOff(bitset<ANUM>& bits
+        , vector<int> &off){
+    off.clear();
+    for(int i = 0; i < ANUM; i++)
+        if(bits[i])
+            off.push_back(i);
+}
+
+void FilterHVLockFreeOp::bitsetToOff(bitset<ANUM>& full, bitset<ANUM>& sub
+        , vector<int> &off){
+    off.clear();
+    int cur = 0;
+    for(int i = 0; i < ANUM; i++){
+        if(sub[i])
+            off.push_back(cur);
+        if(full[i])
+            cur++;
+    }
+}
+
+void FilterHVLockFreeOp::appendToHashtable(uint64_t tid, VTYPE* tuple
+        , vector<int>* proj_off_hashtable, vector<int>* proj_off_seg
+        , int query_proj_count, unsigned short t){
+
+    void* ht_tuple = NULL;
+    VTYPE* ht_tuple_data;
+    unsigned int bucket, slot;
+    
+    if(tuple_status[tid] == VALID)
+        findInHashtable(tid, ht_tuple, bucket, slot);
+    else{
+        bucket = (tid << _log_buckets) / TNUM;
+        //bucket = hasher.hash((void*) &tid);
+        //bucket = tid & _hash_mask;
+
+        ht_tuple = hashtable->allocate(bucket, this);
+        *(uint64_t*)ht_tuple = tid;
+        ht_tuple_data = (VTYPE*)((char*) ht_tuple + sizeof(uint64_t));
+        for(int i = 0; i < query_proj_count; i++)
+            ht_tuple_data[i] = INVALID_VALUE;
+    }
+
+    ht_tuple_data = (VTYPE*)((char*) ht_tuple + sizeof(uint64_t));
+    for(int i = 0; i < proj_off_seg->size(); i++)
+        ht_tuple_data[(*proj_off_hashtable)[i]] = 
+            tuple[(*proj_off_seg)[i]];
+}
+
+void FilterHVLockFreeOp::findInHashtable(uint64_t tid, void* &ht_tuple
+        , unsigned int &bucket, unsigned int &slot){
+    
+    bucket = (tid << _log_buckets) / TNUM;
+    //bucket = hasher.hash((void*) &tid);
+    //bucket = tid & _hash_mask;
+    HashTable::Iterator it;
+    hashtable->placeIterator(it, bucket);
+    slot = 0;
+    while((ht_tuple = it.next())){
+        if(*(uint64_t*)ht_tuple == tid)
+            break;
+        slot++;
+    }
+}
+
+FilterHVLockFreeOp::TupleIterator::TupleIterator(Segment<VTYPE>* seg
+                , unsigned int log_buckets, Status* status
+                , unsigned short threadnum, unsigned short threadid
+                , unsigned int min_bucket, unsigned int max_bucket)
+    : seg(seg), _log_buckets(log_buckets), status(status)
+    , threadnum(threadnum), threadid(threadid), _min(min_bucket)
+    , _max(max_bucket){
+
+
+    this->tnum = seg->getTupleNum();
+    this->cur = findStartTuple(seg, _min, _max);
+}
+
+uint64_t FilterHVLockFreeOp::TupleIterator::findStartTuple(
+        Segment<VTYPE>* seg, unsigned _min, unsigned _max){
+    uint64_t tnum = seg->getTupleNum();
+    uint64_t cur = 0;
+
+    VTYPE* tup;
+    uint64_t bucket;
+    for(cur = 0; cur < tnum; cur += 1024){
+        uint64_t t = seg->getTuple(cur, tup);
+        bucket = (t << _log_buckets) / TNUM;
+        if(bucket >= _min)
+            break;
+    }
+    
+    if(bucket < _min){
+        for(; cur < tnum; cur++){
+            uint64_t t = seg->getTuple(cur, tup);
+            bucket = (t << _log_buckets) / TNUM;
+            if(bucket >= _min)
+                break;
+        }
+    }
+
+    //the start point should be in[cur-1024, cur]
+    uint64_t end = min(cur + 1, tnum);
+    cur = cur > 1024? cur - 1024 : 0;
+
+    for(; cur < end; cur++){
+        uint64_t t = seg->getTuple(cur, tup);
+        bucket = (t << _log_buckets) / TNUM;
+        if(bucket >= _min)
+            break;
+    }
+
+    return cur;
+}
+
+uint64_t FilterHVLockFreeOp::TupleIterator::getNext(VTYPE* &tuple
+        , unsigned int& bucket){
+    
+    uint64_t tid = -1;
+    while(cur < tnum){
+        uint64_t t = seg->getTuple(cur, tuple);
+        cur++;
+      
+        bucket = (t << _log_buckets) / TNUM;
+        //bucket = hasher->hash((void*) &t);
+        //bucket = t & _hash_mask;
+        if(bucket >= _min && bucket < _max &&
+        //if(bucket % threadnum == threadid &&
+                this->status[t] != INVALID){
+            tid = t;
+            break;
+        }else if(bucket >= _max)
+            break;
+    }
+
+    return tid;
+}
diff --git a/operators/partitions/filterhv-lock-free-seq.h b/operators/partitions/filterhv-lock-free-seq.h
new file mode 100644
index 0000000..51294f2
--- /dev/null
+++ b/operators/partitions/filterhv-lock-free-seq.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FILTER_HV__
+#define __FILTER_HV__
+
+#include "../operators.h"
+#include "../operators_priv.h"
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/partitionquery.h"
+#include "../../util/partitions/hashtabledelete.h"
+#include "../../util/partitions/segment.h"
+#include "../../util/partitions/partition.h"
+
+#include <vector>
+#include <cstdint>
+#include <bitset>
+#include <string>
+using namespace std;
+
+class FilterHVLockFreeOp: public virtual ZeroInputOp{
+
+public:
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual void destroy() {
+        delete[] tuple_status;
+    }
+    virtual GetNextResultT getNext(unsigned short threadid);
+private:
+    
+    string data_dir;
+
+    PQuery<VTYPE>* query;
+    HashTableD* hashtable;
+    //TupleHasher hasher;
+    //unsigned int _hash_mask;
+    unsigned int _log_buckets;
+   
+    //0 has not been checked yet (not in the hashtable)
+    //1 valid and stored in the hashtable 
+    //2 invalid and not in the hashtable
+    //char* tuple_status;
+    enum Status{
+        NOT_CHECKED,
+        VALID,
+        INVALID
+    };
+
+    Status* tuple_status;
+
+    int thread_num;
+    
+    vector<vector<int>> workload;
+    vector<int> workload_cur;
+    vector<Partition<VTYPE>*> partitions;
+   
+    //the number of partitions shoudl be processed in a getNext call
+    int process_part_num; 
+
+    pthread_barrier_t return_barrier;
+    pthread_barrier_t process_barrier;
+
+    void processSegment(Segment<VTYPE>& seg, unsigned short threadid);
+
+    void bitsetToOff(bitset<ANUM>& bits, vector<int>& off);
+    void bitsetToOff(bitset<ANUM>& full, bitset<ANUM>& sub
+            , vector<int>& off);
+
+
+    //hashtable operations
+    void findInHashtable(uint64_t tid, void* &ht_tuple
+            , unsigned int &bucket, unsigned int& slot);
+    void appendToHashtable(uint64_t tid, VTYPE* tuple
+            , vector<int>* proj_off_hashtable, vector<int>* proj_off_seg
+            , int query_proj_count, unsigned short threadid);
+    
+    class TupleIterator{
+    public:
+        TupleIterator(Segment<VTYPE>* seg
+                , unsigned int log_buckets, Status* status
+                , unsigned short threadnum, unsigned short threadid
+                , unsigned int min_bucket, unsigned int max_bucket);
+        /*
+         * Get the next valid tuple and lock the bucket
+         * Return -1 if no more valid tuple
+         */
+        uint64_t getNext(VTYPE* &tuple, unsigned int& bucket);
+    private:
+        Segment<VTYPE>* seg;
+        
+        unsigned int _log_buckets;
+        //TupleHasher* hasher;
+        //unsigned int _hash_mask;
+        unsigned int _min, _max;
+        Status* status;
+        uint64_t tnum;
+        uint64_t cur;
+
+        unsigned short threadid;
+        unsigned short threadnum;
+
+        uint64_t findStartTuple(Segment<VTYPE>* seg, unsigned _min
+                , unsigned _max);
+    };
+    
+};
+
+
+#endif
diff --git a/operators/partitions/filterhv-seq.cpp b/operators/partitions/filterhv-seq.cpp
new file mode 100644
index 0000000..e77c5f7
--- /dev/null
+++ b/operators/partitions/filterhv-seq.cpp
@@ -0,0 +1,323 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifdef ENABLE_NUMA
+#define NUMA_VERSION1_COMPATIBILITY //< v1 is widely available 
+#include <numa.h>
+#endif
+
+#include "filterhv-seq.h"
+#include "../../util/numaallocate.h"
+#include "../../util/atomics.h"
+#include "../../util/partitions/partition.h"
+#include "../../util/partitions/segment.h"
+
+#include <sstream>
+#include <iostream>
+#include <sys/time.h>
+
+#define BILLION 1000000000LL
+
+using std::cerr;
+
+#ifdef PERF
+#include "../../util/partitions/profiler_trace.h"
+extern ProfilerTrace trace;
+//operations
+//  start I/O, end I/O
+//  start process, end process
+#endif
+
+void FilterHVOp::init(libconfig::Config& root, libconfig::Setting& node){
+    Operator::init(root, node);
+    data_dir = (const char*) root.getRoot()["path"];
+
+    unsigned long tmp;
+    tmp = node["query"];
+    query = (PQuery<VTYPE>*)tmp;
+    tmp = node["hashtable"];
+    hashtable = (HashTableD*) tmp;
+
+    ostringstream oss;
+    int buckets = node["hash"]["buckets"];
+    
+    _log_buckets = getlogarithm(buckets);
+    buckets = 1 << _log_buckets;
+    
+    int bucketsize = node["tuplesperbucket"];
+    int hash_tuple_size = sizeof(VTYPE) * query->projection.count()
+        + sizeof(uint64_t);
+    bucketsize *= hash_tuple_size;
+
+	string policystr = node["allocpolicy"];
+    
+    vector<char> allocpolicy;
+	if (policystr == "striped")
+	{
+#ifdef ENABLE_NUMA
+		int maxnuma = numa_max_node() + 1;
+		if (node.exists("stripeon"))
+		{
+			// Stripe data on user-specified NUMA nodes.
+			//
+			libconfig::Setting& stripenode = node["stripeon"];
+			for (int i=0; i<stripenode.getLength(); ++i)
+			{
+				int v = stripenode[i];
+				assert(0 <= v);
+				assert(v < maxnuma);
+				allocpolicy.push_back(static_cast<char>(v));
+			}
+		}
+		else
+		{
+			// No constraint specified, stripe on all NUMA nodes.
+			//
+			for (char i=0; i<maxnuma; ++i)
+			{
+				allocpolicy.push_back(i);
+			}
+		}
+#else
+		cerr << " ** NUMA POLICY WARNING: Memory policy is ignored, "
+			<< "NUMA disabled at compile." << endl;
+#endif
+	}
+   
+    hashtable->init(buckets, bucketsize, hash_tuple_size
+            , allocpolicy, this);
+
+    //assign partitions to threads
+    int thread_num = node["threadnum"];
+    libconfig::Setting& filegrep = node["files"];
+    for(int i = 0; i < thread_num; i++){
+        workload.push_back(vector<int>());
+        workload_cur.push_back(0);
+        for(int j = i; j < filegrep.getLength(); j += thread_num){
+            int pid = filegrep[j];
+            workload[i].push_back(pid);
+        }
+    }
+
+    //tuple_status = new char[TNUM];
+    //memset(tuple_status, 0, TNUM);
+    tuple_status = new Status[TNUM];
+    for(uint64_t i = 0; i < TNUM; i++)
+        tuple_status[i] = NOT_CHECKED;
+}
+
+Operator::GetNextResultT FilterHVOp::getNext(unsigned short t){
+    if(workload_cur[t] >= workload[t].size())
+        return make_pair(Operator::Finished, &EmptyPage);
+
+#ifdef PERF
+    trace.add(t, "start I/O");
+#endif
+
+    string filepath = data_dir + "/p_" 
+        + std::to_string(workload[t][workload_cur[t]]);
+    Partition<VTYPE>* p = Partition<VTYPE>
+        ::readFromFile(t, filepath.c_str());
+
+#ifdef PERF
+    trace.add(t, "end I/O");
+    trace.add(t, "start process");
+#endif
+    
+    //cout << "thread " << t << " processes "  << filepath << endl;
+    
+    //get the segments 
+    vector<Segment<VTYPE>> segments;
+    p->getSegments(segments);
+    for(auto& s : segments){
+        processSegment(s, t);
+    }
+   
+#ifdef PERF
+    trace.add(t, "end process");
+#endif
+
+    delete p;
+    workload_cur[t]++;
+    return make_pair(Operator::Ready, &EmptyPage);
+}
+
+void FilterHVOp::processSegment(Segment<VTYPE> &seg, unsigned short t){
+#ifdef PERF
+    trace.add(t, "start init iterator");
+#endif
+    uint64_t tuple_num = seg.getTupleNum();
+    
+    bitset<ANUM> cols = seg.getColumns();
+
+    bitset<ANUM> sel_cols = cols & query->selection;
+    bitset<ANUM> proj_cols = cols & query->projection;
+
+    //the offset in the segment and the attribute id
+    vector<int> sel_off_seg, sel_aids;
+    bitsetToOff(cols, sel_cols, sel_off_seg);
+    bitsetToOff(sel_cols, sel_aids);
+
+    //the offset in the segment and in the total projection attributes
+    vector<int> proj_off_seg, proj_off_proj;
+    bitsetToOff(cols, proj_cols, proj_off_seg);
+    bitsetToOff(query->projection, proj_cols, proj_off_proj);
+
+    int sel_count = sel_cols.count();
+    int proj_count = proj_cols.count();
+    int query_proj_count = query->projection.count();
+    VTYPE* sel_data = new VTYPE[sel_count];
+
+    VTYPE* seg_tup;
+    uint64_t tid;
+    unsigned int slot, bucket;
+
+
+    TupleIterator tup_it(&seg, hashtable, _log_buckets, tuple_status, t);
+#ifdef PERF
+    trace.add(t, "end init iterator");
+#endif
+    while((tid = tup_it.getNext(seg_tup, bucket)) != -1){
+        
+    //check the predicates
+        for(int j = 0; j < sel_count; j++)
+            sel_data[j] = seg_tup[sel_off_seg[j]]; 
+        bool pass = query->evaluate(sel_data, sel_aids);
+
+        Status& status = tuple_status[tid];
+        
+        //the tuple does not satify the query and not in the hashtable
+        if(status == NOT_CHECKED && !pass){
+            status = INVALID;
+            hashtable->unlockbucket(bucket);
+            continue;
+        }
+
+        //the tuple satisfies the query and already in the hashtable
+        //but does not contain any projected attributes
+        if(status == VALID && pass && proj_count == 0){
+            hashtable->unlockbucket(bucket);
+            continue;
+        }
+
+        if(pass){
+            appendToHashtable(tid, seg_tup, &proj_off_proj, &proj_off_seg
+                    , query_proj_count, t);
+            status = VALID;
+        } else{
+
+            void* ht_tuple;
+            findInHashtable(tid, ht_tuple, bucket, slot);
+            hashtable->Delete(bucket, slot);
+            status = INVALID;
+        }
+        hashtable->unlockbucket(bucket);
+    }
+
+}
+
+void FilterHVOp::bitsetToOff(bitset<ANUM>& bits, vector<int> &off){
+    off.clear();
+    for(int i = 0; i < ANUM; i++)
+        if(bits[i])
+            off.push_back(i);
+}
+
+void FilterHVOp::bitsetToOff(bitset<ANUM>& full, bitset<ANUM>& sub
+        , vector<int> &off){
+    off.clear();
+    int cur = 0;
+    for(int i = 0; i < ANUM; i++){
+        if(sub[i])
+            off.push_back(cur);
+        if(full[i])
+            cur++;
+    }
+}
+
+void FilterHVOp::appendToHashtable(uint64_t tid, VTYPE* tuple
+        , vector<int>* proj_off_hashtable, vector<int>* proj_off_seg
+        , int query_proj_count, unsigned short t){
+
+    void* ht_tuple = NULL;
+    VTYPE* ht_tuple_data;
+    unsigned int bucket, slot;
+    
+    if(tuple_status[tid] == VALID)
+        findInHashtable(tid, ht_tuple, bucket, slot);
+    else{
+        bucket = (tid << _log_buckets) / TNUM;
+        ht_tuple = hashtable->allocate(bucket, this);
+        *(uint64_t*)ht_tuple = tid;
+        ht_tuple_data = (VTYPE*)((char*) ht_tuple + sizeof(uint64_t));
+        for(int i = 0; i < query_proj_count; i++)
+            ht_tuple_data[i] = INVALID_VALUE;
+    }
+
+    ht_tuple_data = (VTYPE*)((char*) ht_tuple + sizeof(uint64_t));
+    for(int i = 0; i < proj_off_seg->size(); i++)
+        ht_tuple_data[(*proj_off_hashtable)[i]] = 
+            tuple[(*proj_off_seg)[i]];
+}
+
+void FilterHVOp::findInHashtable(uint64_t tid, void* &ht_tuple
+        , unsigned int &bucket, unsigned int &slot){
+    bucket = (tid << _log_buckets) / TNUM;
+    HashTable::Iterator it;
+    hashtable->placeIterator(it, bucket);
+    slot = 0;
+    while((ht_tuple = it.next())){
+        if(*(uint64_t*)ht_tuple == tid)
+            break;
+        slot++;
+    }
+}
+
+uint64_t FilterHVOp::TupleIterator::getNext(VTYPE* &tuple
+        , unsigned int& bucket){
+    uint64_t tid = -1;
+    while(cur < tnum){
+        tid = seg->getTuple(cur, tuple);
+        cur++;
+        bucket = (tid << _log_buckets) / TNUM;
+
+        hashtable->lockbucket(bucket);
+        
+        if(this->status[tid] == INVALID){
+            hashtable->unlockbucket(bucket);
+            tid = -1;
+        } else
+            break;
+    }
+    
+    return tid;
+}
diff --git a/operators/partitions/filterhv-seq.h b/operators/partitions/filterhv-seq.h
new file mode 100644
index 0000000..8dcbcd2
--- /dev/null
+++ b/operators/partitions/filterhv-seq.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FILTER_HV__
+#define __FILTER_HV__
+
+#include "../operators.h"
+#include "../operators_priv.h"
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/partitionquery.h"
+#include "../../util/partitions/hashtabledelete.h"
+#include "../../util/partitions/segment.h"
+
+#include <vector>
+#include <cstdint>
+#include <bitset>
+#include <string>
+using namespace std;
+
+class FilterHVOp: public virtual ZeroInputOp{
+
+public:
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    virtual void destroy() {
+        delete[] tuple_status;
+    }
+    virtual GetNextResultT getNext(unsigned short threadid);
+private:
+    
+    string data_dir;
+
+    PQuery<VTYPE>* query;
+    HashTableD* hashtable;
+    //TupleHasher hasher;
+    unsigned int _log_buckets;
+   
+    //0 has not been checked yet (not in the hashtable)
+    //1 valid and stored in the hashtable 
+    //2 invalid and not in the hashtable
+    //char* tuple_status;
+    enum Status{
+        NOT_CHECKED,
+        VALID,
+        INVALID
+    };
+
+    Status* tuple_status;
+
+    vector<vector<int>> workload;
+    vector<int> workload_cur;
+
+    void processSegment(Segment<VTYPE>& seg, unsigned short threadid);
+
+    void bitsetToOff(bitset<ANUM>& bits, vector<int>& off);
+    void bitsetToOff(bitset<ANUM>& full, bitset<ANUM>& sub
+            , vector<int>& off);
+
+
+    //hashtable operations
+    void findInHashtable(uint64_t tid, void* &ht_tuple
+            , unsigned int &bucket, unsigned int& slot);
+    void appendToHashtable(uint64_t tid, VTYPE* tuple
+            , vector<int>* proj_off_hashtable, vector<int>* proj_off_seg
+            , int query_proj_count, unsigned short threadid);
+    
+    class TupleIterator{
+    public:
+        TupleIterator(Segment<VTYPE>* seg, HashTableD* table
+                , unsigned int log_buckets, Status* status
+                , unsigned short threadid): seg(seg), hashtable(table)
+                    , _log_buckets(log_buckets), status(status)
+                    , threadid(threadid){
+        
+            this->tnum = seg->getTupleNum();              
+        }
+        /*
+         * Get the next valid tuple and lock the bucket
+         * Return -1 if no more valid tuple
+         */
+        uint64_t getNext(VTYPE* &tuple, unsigned int& bucket);
+    private:
+        Segment<VTYPE>* seg;
+        HashTableD* hashtable;
+        //TupleHasher* hasher;
+        unsigned int _log_buckets;
+        Status* status;
+        uint64_t tnum;
+        uint64_t cur = 0;
+
+        unsigned short threadid;
+    };
+    
+};
+
+#endif
diff --git a/operators/partitions/projecthv-lock-free-seq.cpp b/operators/partitions/projecthv-lock-free-seq.cpp
new file mode 100644
index 0000000..1a2c32d
--- /dev/null
+++ b/operators/partitions/projecthv-lock-free-seq.cpp
@@ -0,0 +1,293 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifdef ENABLE_NUMA
+#define NUMA_VERSION1_COMPATIBILITY //< v1 is widely available 
+#include <numa.h>
+#endif
+
+#include "projecthv-lock-free-seq.h"
+#include <iostream>
+#include <vector>
+#include <sstream>
+
+using std::cerr;
+
+#ifdef PERF
+#include "../../util/partitions/profiler_trace.h"
+extern ProfilerTrace trace;
+
+//operations
+//  start I/O, end I/O
+//  start sync, end sync
+//  start process, end process 
+#endif
+
+void ProjectHVLockFreeOp::init(libconfig::Config& root, libconfig::Setting& node){
+    Operator::init(root, node);
+    data_dir = (const char*) root.getRoot()["path"];
+
+    unsigned long tmp;
+    tmp = node["query"];
+    query = (PQuery<VTYPE>*)tmp;
+    tmp = node["hashtable"];
+    hashtable = (HashTableD*) tmp;
+    tmp = node["index"];
+    index = (Index*) tmp;
+    
+    threadnum = node["threadnum"];
+
+    _log_buckets = getlogarithm(hashtable->getNumberOfBuckets());
+    
+    unsigned int bucket_step = hashtable->getNumberOfBuckets() 
+                                            / threadnum;
+    for(int i = 0; i < threadnum; i++)
+        assign_buckets.push_back(make_pair(i*bucket_step
+                                    , (i+1) * bucket_step));
+    assign_buckets[threadnum - 1].second = hashtable->getNumberOfBuckets();
+    parts_cur.resize(threadnum, 0);
+    pthread_barrier_init(&find_part_barrier, NULL, threadnum);
+}
+
+
+Operator::GetNextResultT ProjectHVLockFreeOp::getNext(unsigned short t){
+    HashTable::Iterator it = hashtable->createIterator();
+
+    int query_proj_count = query->projection.count();
+    vector<int> proj_aids = query->getProjection();
+    void* ht_tuple;
+    VTYPE* ht_tuple_data;
+
+    for(unsigned int b = assign_buckets[t].first
+            ; b < assign_buckets[t].second; b++){
+        hashtable->placeIterator(it, b);
+        while((ht_tuple = it.next())){
+            ht_tuple_data = (VTYPE*)((char*)ht_tuple + sizeof(uint64_t));
+            for(int i = 0; i < query_proj_count; i++){
+                if(ht_tuple_data[i] != INVALID_VALUE)
+                    continue;
+                
+                //the cell has not been filled
+                uint64_t tid = *(uint64_t*)ht_tuple; 
+                int pid = index->getPartitionByCell(tid, proj_aids[i]); 
+                
+                //check if the partition has been processed
+                bool io = false;
+                io_part_lock.lock();
+                if(io_part.find(pid) == io_part.end()){
+                    io = true;
+                    io_part.insert(pid);
+                }
+                io_part_lock.unlock();
+
+                //Read the partition if it has not been read
+                if(io)
+                    readPartition(pid, t);
+            }
+        }
+
+        //check if new partitions are in the parts
+        if(parts.size() > parts_cur[t]){
+            processPartitions(t);
+        }
+    }
+
+
+    //finally make sure to process all partitions
+#ifdef PERF
+    trace.add(t, "start sync");
+#endif
+
+    pthread_barrier_wait(&find_part_barrier);
+
+#ifdef PERF
+    trace.add(t, "end sync");
+#endif
+
+    processPartitions(t);
+
+    return make_pair(Operator::Finished, &EmptyPage);
+}
+
+void ProjectHVLockFreeOp::readPartition(uint64_t pid, unsigned short t){
+#ifdef PERF
+    trace.add(t, "start I/O");
+#endif
+    string file_path = data_dir + "/p_" + std::to_string(pid);
+    Partition<VTYPE>* p = Partition<VTYPE>::readFromFile(t
+                        , file_path.c_str());
+    //place the partition to the parts vector
+    part_lock.lock();
+    parts.push_back(std::make_pair(p, 0));
+    part_lock.unlock();
+
+#ifdef PERF
+    trace.add(t, "end I/O");
+#endif
+
+}
+
+void ProjectHVLockFreeOp::processPartitions(unsigned short t){
+#ifdef PERF
+    trace.add(t, "start process");
+#endif
+
+    for(uint64_t i = parts_cur[t]; i < parts.size(); i++){
+        if(parts[i].first == NULL)
+            return;
+        parts_cur[t]++;
+        Partition<VTYPE>* p = parts[i].first;
+        
+        vector<Segment<VTYPE>> segments;
+        p->getSegments(segments);
+        for(auto& s : segments)
+            processSegment(s, t);
+
+        //increase the #threads for the partition
+        part_lock.lock();
+        parts[i].second++;
+        if(parts[i].second == threadnum){
+            delete parts[i].first;
+            parts[i].first = NULL;
+        }
+        part_lock.unlock();
+    }
+
+#ifdef PERF
+    trace.add(t, "end process");
+#endif
+}
+
+void ProjectHVLockFreeOp::processSegment(Segment<VTYPE>& seg
+        , unsigned short t){
+
+    uint64_t tuple_num = seg.getTupleNum();
+    
+    bitset<ANUM> cols = seg.getColumns();
+    bitset<ANUM> proj_cols = cols & query->projection;
+    
+    //the offset in the segment and in the total projection attributes
+    vector<int> proj_off_seg, proj_off_proj;
+    bitsetToOff(cols, proj_cols, proj_off_seg);
+    bitsetToOff(query->projection, proj_cols, proj_off_proj);
+    int proj_count = proj_cols.count();
+    
+    VTYPE* seg_tup;
+    uint64_t tid;
+    HashTable::Iterator it = hashtable->createIterator();
+    void* ht_tuple;
+    VTYPE* ht_tuple_data;
+   
+    unsigned int _min(assign_buckets[t].first)
+        , _max(assign_buckets[t].second);
+    
+    uint64_t i = findStartTuple(&seg, _min, _max); 
+    for( ; i < tuple_num; i++){
+        tid = seg.getTuple(i, seg_tup); 
+        unsigned int bucket = (tid << _log_buckets) / TNUM;
+        if(bucket >= _max)
+            break;
+        
+        //if(bucket < _min || bucket >= _max)
+        //    continue;
+        
+        hashtable->placeIterator(it, bucket);
+        while((ht_tuple = it.next())){
+            if(*(uint64_t*)ht_tuple == tid)
+                break;
+        }
+
+        if(ht_tuple == NULL)
+            continue;
+        ht_tuple_data = (VTYPE*)((char*)ht_tuple + sizeof(uint64_t));
+        for(int j = 0; j < proj_count; j++)
+            ht_tuple_data[proj_off_proj[j]] = seg_tup[proj_off_seg[j]];
+    }
+
+}
+
+uint64_t ProjectHVLockFreeOp::findStartTuple(
+        Segment<VTYPE>* seg, unsigned _min, unsigned _max){
+    uint64_t tnum = seg->getTupleNum();
+    uint64_t cur = 0;
+
+    VTYPE* tup;
+    uint64_t bucket;
+    for(cur = 0; cur < tnum; cur += 1024){
+        uint64_t t = seg->getTuple(cur, tup);
+        bucket = (t << _log_buckets) / TNUM;
+        if(bucket >= _min)
+            break;
+    }
+    
+    if(bucket < _min){
+        for(; cur < tnum; cur++){
+            uint64_t t = seg->getTuple(cur, tup);
+            bucket = (t << _log_buckets) / TNUM;
+            if(bucket >= _min)
+                break;
+        }
+    }
+
+    //the start point should be in[cur-1024, cur]
+    uint64_t end = min(cur + 1, tnum);
+    cur = cur > 1024? cur - 1024 : 0;
+
+    for(; cur < end; cur++){
+        uint64_t t = seg->getTuple(cur, tup);
+        bucket = (t << _log_buckets) / TNUM;
+        if(bucket >= _min)
+            break;
+    }
+
+    return cur;
+}
+
+void ProjectHVLockFreeOp::bitsetToOff(bitset<ANUM>& bits
+        , vector<int> &off){
+    off.clear();
+    for(int i = 0; i < ANUM; i++)
+        if(bits[i])
+            off.push_back(i);
+}
+
+void ProjectHVLockFreeOp::bitsetToOff(bitset<ANUM>& full
+        , bitset<ANUM>& sub, vector<int> &off){
+    off.clear();
+    int cur = 0;
+    for(int i = 0; i < ANUM; i++){
+        if(sub[i])
+            off.push_back(cur);
+        if(full[i])
+            cur++;
+    }
+}
diff --git a/operators/partitions/projecthv-lock-free-seq.h b/operators/partitions/projecthv-lock-free-seq.h
new file mode 100644
index 0000000..13bdfaf
--- /dev/null
+++ b/operators/partitions/projecthv-lock-free-seq.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PROJECT_HV__
+#define __PROJECT_HV__
+
+#include "../../lock.h"
+#include "../operators.h"
+#include "../operators_priv.h"
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/partitionquery.h"
+#include "../../util/partitions/hashtabledelete.h"
+#include "../../util/partitions/partition.h"
+#include "../../util/partitions/segment.h"
+#include "../../util/partitions/index.h"
+
+#include <set>
+#include <vector>
+#include <cstdint>
+#include <string>
+#include <utility>
+using namespace std;
+
+class ProjectHVLockFreeOp: public virtual ZeroInputOp{
+
+public:
+
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    //virtual void destroy() { }
+    virtual GetNextResultT getNext(unsigned short threadid);
+
+private:
+
+    //before read a partition, place the pid to the io_part set
+    //after read it, place the partition pointer to the parts vector
+    //delete the partition after all threads process it
+    set<int> io_part;
+    Lock io_part_lock;
+    vector<std::pair<Partition<VTYPE>*, int>> parts;
+    Lock part_lock;
+    vector<uint64_t> parts_cur;
+
+    string data_dir;
+    PQuery<VTYPE>* query;
+    HashTableD* hashtable;
+    unsigned int _log_buckets;
+
+    Index* index;
+    int threadnum;
+    vector<std::pair<unsigned int, unsigned int>> assign_buckets;
+
+    pthread_barrier_t find_part_barrier;
+   
+    void readPartition(uint64_t pid, unsigned short threadid);
+    void processPartitions(unsigned short threadid);
+
+    void processSegment(Segment<VTYPE>& seg, unsigned short threadid);
+
+    uint64_t findStartTuple(Segment<VTYPE>* seg, unsigned _min_bucket
+            , unsigned _max_bucket);
+
+    void bitsetToOff(bitset<ANUM>& bits, vector<int>& off);
+    void bitsetToOff(bitset<ANUM>& full, bitset<ANUM>& sub
+            , vector<int>& off);
+};
+
+#endif
diff --git a/operators/partitions/projecthv-seq.cpp b/operators/partitions/projecthv-seq.cpp
new file mode 100644
index 0000000..d718a30
--- /dev/null
+++ b/operators/partitions/projecthv-seq.cpp
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifdef ENABLE_NUMA
+#define NUMA_VERSION1_COMPATIBILITY //< v1 is widely available 
+#include <numa.h>
+#endif
+
+#include "projecthv-seq.h"
+#include "../../util/partitions/partition.h"
+#include <iostream>
+#include <vector>
+#include <sstream>
+
+using std::cerr;
+
+#ifdef PERF
+#include "../../util/partitions/profiler_trace.h"
+extern ProfilerTrace trace;
+
+//operations
+//  start I/O, end I/O
+//  start process, end process 
+#endif
+
+void ProjectHVOp::init(libconfig::Config& root, libconfig::Setting& node){
+    Operator::init(root, node);
+    data_dir = (const char*) root.getRoot()["path"];
+
+    unsigned long tmp;
+    tmp = node["query"];
+    query = (PQuery<VTYPE>*)tmp;
+    tmp = node["hashtable"];
+    hashtable = (HashTableD*) tmp;
+    tmp = node["index"];
+    index = (Index*) tmp;
+    
+    threadnum = node["threadnum"];
+    
+    _log_buckets = getlogarithm(hashtable->getNumberOfBuckets());
+}
+
+Operator::GetNextResultT ProjectHVOp::getNext(unsigned short t){
+    uint64_t nbucket = hashtable->getNumberOfBuckets();
+    HashTable::Iterator it = hashtable->createIterator();
+
+    int query_proj_count = query->projection.count();
+    vector<int> proj_aids = query->getProjection();
+    
+    void* ht_tuple;
+    VTYPE* ht_tuple_data;
+
+    for(uint64_t b = t; b < nbucket; b += threadnum){
+        //process a bucket
+        hashtable->placeIterator(it, b);
+        while((ht_tuple = it.next())){
+            ht_tuple_data = (VTYPE*)((char*)ht_tuple + sizeof(uint64_t));
+            for(int i = 0; i < query_proj_count; i++){
+                if(ht_tuple_data[i] != INVALID_VALUE)
+                    continue;
+                
+                //the cell has not been filled
+                uint64_t tid = *(uint64_t*)ht_tuple; 
+                int pid = index->getPartitionByCell(tid, proj_aids[i]); 
+
+                //check if the partition has been processed
+                bool process = false;
+                processed_part_lock.lock();
+                if(processed_part.find(pid) == processed_part.end()){
+                    process = true;
+                    processed_part.insert(pid);
+                }
+                processed_part_lock.unlock();
+
+                //process the partition
+                if(process){
+                    processPartition(t, pid); 
+                }
+            }
+        }
+    }
+
+    return make_pair(Operator::Finished, &EmptyPage);
+}
+
+void ProjectHVOp::processPartition(unsigned short threadid, int pid){
+#ifdef PERF
+    trace.add(threadid, "start I/O");
+#endif
+
+    string filepath = data_dir + "/p_" + std::to_string(pid);
+    Partition<VTYPE>* p = Partition<VTYPE>
+        ::readFromFile(threadid, filepath.c_str());
+#ifdef PERF
+    trace.add(threadid, "end I/O");
+    trace.add(threadid, "start process");
+#endif
+
+    //cout << "thread " << threadid << " process " << filepath << endl;
+    vector<Segment<VTYPE>> segments;
+    p->getSegments(segments);
+    for(auto& s: segments)
+        processSegment(s, threadid);
+
+    delete p;
+
+#ifdef PERF
+    trace.add(threadid, "end process");
+#endif
+}
+
+void ProjectHVOp::processSegment(Segment<VTYPE>& seg, unsigned short t){
+
+    uint64_t tuple_num = seg.getTupleNum();
+    
+    bitset<ANUM> cols = seg.getColumns();
+    bitset<ANUM> proj_cols = cols & query->projection;
+    
+    //the offset in the segment and in the total projection attributes
+    vector<int> proj_off_seg, proj_off_proj;
+    bitsetToOff(cols, proj_cols, proj_off_seg);
+    bitsetToOff(query->projection, proj_cols, proj_off_proj);
+    int proj_count = proj_cols.count();
+    
+    VTYPE* seg_tup;
+    uint64_t tid;
+    HashTable::Iterator it = hashtable->createIterator();
+    void* ht_tuple;
+    VTYPE* ht_tuple_data;
+    
+    for(uint64_t i = 0; i < tuple_num; i++){
+        tid = seg.getTuple(i, seg_tup); 
+        unsigned int bucket = (tid << _log_buckets) / TNUM;
+        //unsigned int bucket = hasher.hash((void*)(&tid));
+        hashtable->placeIterator(it, bucket);
+        while((ht_tuple = it.next())){
+            if(*(uint64_t*)ht_tuple == tid)
+                break;
+        }
+
+        if(ht_tuple == NULL)
+            continue;
+        ht_tuple_data = (VTYPE*)((char*)ht_tuple + sizeof(uint64_t));
+        for(int j = 0; j < proj_count; j++)
+            ht_tuple_data[proj_off_proj[j]] = seg_tup[proj_off_seg[j]];
+        
+    }
+
+}
+
+void ProjectHVOp::bitsetToOff(bitset<ANUM>& bits, vector<int> &off){
+    off.clear();
+    for(int i = 0; i < ANUM; i++)
+        if(bits[i])
+            off.push_back(i);
+}
+
+void ProjectHVOp::bitsetToOff(bitset<ANUM>& full, bitset<ANUM>& sub
+        , vector<int> &off){
+    off.clear();
+    int cur = 0;
+    for(int i = 0; i < ANUM; i++){
+        if(sub[i])
+            off.push_back(cur);
+        if(full[i])
+            cur++;
+    }
+}
diff --git a/operators/partitions/projecthv-seq.h b/operators/partitions/projecthv-seq.h
new file mode 100644
index 0000000..91ca466
--- /dev/null
+++ b/operators/partitions/projecthv-seq.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PROJECT_HV__
+#define __PROJECT_HV__
+
+#include "../../lock.h"
+#include "../operators.h"
+#include "../operators_priv.h"
+#include "../../util/partitions/constants.h"
+#include "../../util/partitions/partitionquery.h"
+#include "../../util/partitions/hashtabledelete.h"
+#include "../../util/partitions/segment.h"
+#include "../../util/partitions/index.h"
+
+#include <set>
+#include <vector>
+#include <cstdint>
+#include <string>
+using namespace std;
+
+class ProjectHVOp: public virtual ZeroInputOp{
+
+public:
+
+    virtual void init(libconfig::Config& root, libconfig::Setting& node);
+    //virtual void destroy() { }
+    virtual GetNextResultT getNext(unsigned short threadid);
+
+private:
+
+    //before a thread processes a segment, check if the segment has been
+    //processed. If not, add the seg to the processed_seg and then
+    //process it
+    set<int> processed_part;
+    Lock processed_part_lock;
+
+    string data_dir;
+    PQuery<VTYPE>* query;
+    HashTableD* hashtable;
+    //TupleHasher hasher;
+    unsigned int _log_buckets;
+    Index* index;
+    int threadnum;
+   
+    void processPartition(unsigned short threadid, int pid);
+    void processSegment(Segment<VTYPE>& seg, unsigned short threadid);
+
+    void bitsetToOff(bitset<ANUM>& bits, vector<int>& off);
+    void bitsetToOff(bitset<ANUM>& full, bitset<ANUM>& sub
+            , vector<int>& off);
+};
+
+#endif
diff --git a/operators/sleep.h b/operators/sleep.h
new file mode 100644
index 0000000..b1ec921
--- /dev/null
+++ b/operators/sleep.h
@@ -0,0 +1,7 @@
+#ifndef __SLEEPOP__
+#define __SLEEPOP__
+
+#include "operators.h"
+
+
+#endif
diff --git a/unit_tests/partitions/test_hashtabled.cpp b/unit_tests/partitions/test_hashtabled.cpp
new file mode 100644
index 0000000..0b7b59f
--- /dev/null
+++ b/unit_tests/partitions/test_hashtabled.cpp
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <iostream>
+#include "../common.h"
+#include "../../util/partitions/hashtabledelete.h"
+#include "../../util/hashtable.h"
+#include <stdlib.h>
+#include <vector>
+#include <bits/stdc++.h>
+
+using namespace std;
+
+bool testdelete(const int numtuples, const int delnum
+        , const int tupleperbucket, const int buckets){
+    
+
+    HashTableD htd;
+    htd.init(buckets, tupleperbucket * sizeof(int), sizeof(int)
+            , vector<char>(), 0);
+    HashTable ht;
+    ht.init(buckets, tupleperbucket * sizeof(int), sizeof(int)
+            , vector<char>(), 0);
+
+
+    bool del[numtuples] = {false};
+    for(int i = 0; i < delnum; i++){
+        int t = rand() % numtuples;
+        if(del[t])
+            i--;
+        else
+            del[t] = true;
+    }
+
+    for(int i = 0; i < numtuples; i++){
+        *(int*)htd.allocate(i % buckets, 0) = i;
+        if(!del[i])
+           *(int*)ht.allocate(i % buckets, 0) = i; 
+    }
+
+    //delete the tuples
+    HashTable::Iterator itd = htd.createIterator();
+    for(int i = 0; i < numtuples; i++)
+        if(del[i]){
+            htd.placeIterator(itd, i % buckets);
+            int slot = 0;
+            void* tuple;
+            
+            while((tuple = itd.next())){
+                if(*(int*)tuple == i)
+                    break;
+                slot ++;
+            }
+            htd.atomicDelete(i % buckets, slot);
+        }
+
+    //compare the two hash tables
+    HashTable::Iterator it = ht.createIterator();
+    for(int i = 0; i < buckets; i++){
+        htd.placeIterator(itd, i);
+        ht.placeIterator(it, i);
+        
+        vector<int> a, b;
+        void* tuple;
+        while((tuple = itd.next()))
+            a.push_back(*(int*)tuple);
+        while((tuple = it.next()))
+            b.push_back(*(int*)tuple);
+        
+        sort(a.begin(), a.end());
+        sort(b.begin(), b.end());
+        if(a.size() != b.size() || a != b){
+            cout << "Bucket " << i << " is not correct after delete" << endl;
+            for(int i = 0; i < a.size(); i++)
+                cout << a[i] << " ";
+            cout << endl;
+            for(int i = 0; i < b.size(); i++)
+                cout << b[i] << " ";
+            cout << endl;
+            return false;
+        }
+    }
+
+    //insert the deleted tuples
+    for(int i = 0; i < numtuples; i++)
+        if(del[i])
+            *(int*)htd.allocate(i % buckets, 0) = i;
+
+    //Iterator htd and check
+    int count[numtuples] = {0};
+    for(int i = 0; i < buckets; i++){
+        htd.placeIterator(itd, i);
+        void* tuple;
+        while((tuple = itd.next()))
+            count[*(int*)tuple]++;
+    }
+    for(int i = 0; i < numtuples; i++)
+        if(count[i] != 1){
+            cout << "Tuple " << i << " has count " << count[i] << " after re-insert" << endl;
+            return false;
+        }
+
+    return true;
+}
+
+int main(){
+    int numtuples = 1000;
+    int delnum = 400;
+    int buckets = 100;
+    int tuplesperbucket = 2;
+
+    bool ret = testdelete(numtuples, delnum, tuplesperbucket, buckets);
+    if(!ret)
+        fail("fail on delete test");
+
+    return 0;
+}
diff --git a/util/baselines/baselinequery.cc b/util/baselines/baselinequery.cc
new file mode 100644
index 0000000..84fcace
--- /dev/null
+++ b/util/baselines/baselinequery.cc
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "baselinequery.h"
+#include <sstream>
+#include <bits/stdc++.h>
+
+template<typename T>
+uint64_t BaselineQuery<T>::next_qid = 0;
+
+template<typename T>
+BaselineQuery<T>::BaselineQuery(uint64_t qid, const vector<int>& projection
+                , const vector<int>& selection
+                , const vector<T>& ranges
+                , const bitset<2*ANUM>& closed){
+
+    this->qid = qid;
+    for(auto& i : projection)
+        this->projection[i] = 1;
+    for(auto& i : selection)
+        this->selection[i] = 1;
+    this->ranges = ranges;
+    this->closed = closed;
+    this->sel_v = selection;
+}
+
+template<typename T>
+BaselineQuery<T>::BaselineQuery(uint64_t qid, const bitset<ANUM>& projection
+        , const bitset<ANUM>& selection
+        , const vector<T>& ranges
+        , const bitset<2*ANUM>& closed){
+
+    this->qid = qid;
+    this->projection = projection;
+    this->selection = selection;
+    this->ranges = ranges;
+    this->closed = closed;
+
+    for(int i = 0; i < ANUM; i++)
+        if(selection[i] == 1)
+            sel_v.push_back(i);
+
+}
+
+template<typename T>
+BaselineQuery<T>* BaselineQuery<T>::parse_string(string str){
+    stringstream ss(str);
+    string token;
+
+    ss >> token;
+    reverse(token.begin(), token.end());
+    bitset<ANUM> projection(token);
+
+    ss >> token;
+    reverse(token.begin(), token.end());
+    bitset<ANUM> selection(token);
+
+
+//   projection = projection & (projection ^ selection);
+
+   vector<T> ranges;
+   ranges.reserve(2*ANUM);
+   for(int i = 0; i < 2*ANUM; i++){
+       ranges.push_back(0);
+       ss >> ranges[i];
+   }
+
+   ss >> token;
+   reverse(token.begin(), token.end());
+   bitset<2*ANUM> closed(token);
+
+   BaselineQuery<T>* q = new BaselineQuery<T>(next_qid++, projection
+           , selection, ranges, closed);
+   return q;
+}
+
+
+template<typename T>
+vector<int> BaselineQuery<T>::getSelection(){
+    return sel_v;
+}
+
+template<typename T>
+vector<int> BaselineQuery<T>::getProjection(){
+    vector<int> ret;
+    for(int i = 0; i < ANUM; i++)
+        if(projection[i] == 1)
+            ret.push_back(i);
+    return ret;
+}
+
+template<typename T>
+void BaselineQuery<T>::evaluate(T data[], uint64_t tnum
+        , vector<T> &ret, vector<uint64_t>& tids){
+    ret.clear();
+    vector<int> proj_v;
+    for(int i = 0; i < ANUM; i++)
+        if(projection[i] == 1)
+            proj_v.push_back(i);
+
+    T sel_data[sel_v.size()];
+    for(uint64_t i = 0; i < tnum; i++){
+        for(int j = 0; j < sel_v.size(); j++)
+            sel_data[j] = data[i*ANUM + sel_v[j]];
+        if(!this->evaluate(sel_data))
+            continue;
+        for(auto j : proj_v)
+            ret.push_back(data[i*ANUM + j]);
+        tids.push_back(i);
+    }
+}
+
+template class BaselineQuery<VTYPE>;
diff --git a/util/baselines/baselinequery.h b/util/baselines/baselinequery.h
new file mode 100644
index 0000000..032fc7c
--- /dev/null
+++ b/util/baselines/baselinequery.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __QUERY__
+#define __QUERY__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <bitset>
+#include <vector>
+#include <stdint.h>
+
+#include "../partitions/constants.h"
+
+using namespace std;
+
+template <typename T>
+class BaselineQuery{
+public:
+
+    BaselineQuery(uint64_t qid, const vector<int>& projection
+            , const vector<int>& selection
+            , const vector<T>& ranges
+            , const bitset<2*ANUM>& closed);
+
+    BaselineQuery(uint64_t qid, const bitset<ANUM>& projection
+            , const bitset<ANUM>& selection
+            , const vector<T>& ranges
+            , const bitset<2*ANUM>& closed);
+
+    vector<int> getSelection();
+    vector<int> getProjection();
+
+    /*
+     * Check the data in selection attributes satisfy the query
+     * The lenght of sel_data is same as the number of selection attrs
+     */
+    bool evaluate(T sel_data[]);
+
+    /*
+     * Evaluate a set of tuples and place proj attrs of satisfied tuples in ret
+     */
+    void evaluate(T data[], uint64_t tnum, vector<T> &ret, vector<uint64_t> &tids);
+
+    static BaselineQuery<T>* parse_string(string str);
+
+    bitset<ANUM> projection;
+    bitset<ANUM> selection;
+    vector<int> sel_v;
+    vector<T> ranges;
+    bitset<2*ANUM> closed; //the range is closed or not
+    uint64_t qid;
+
+private:
+    static uint64_t next_qid;
+};
+
+template<typename T>
+inline bool BaselineQuery<T>::evaluate(T data[]){
+    for(int i = 0; i < sel_v.size(); i++){
+        T v = data[i];
+        uint64_t aid = sel_v[i];
+        T l(ranges[2*aid]), r(ranges[2*aid+1]);
+        if(v < l || (v == l && closed[2*aid] == 0))
+            return false;
+        if(v > r || (v == r && closed[2*aid + 1] == 0))
+            return false;
+    }
+    return true;
+}
+
+#endif
diff --git a/util/baselines/index.cpp b/util/baselines/index.cpp
new file mode 100644
index 0000000..3efe6f4
--- /dev/null
+++ b/util/baselines/index.cpp
@@ -0,0 +1,192 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "index.h"
+#include <fstream>
+//#include <sstream>
+#include <string>
+#include <algorithm>
+using namespace std;
+
+Index::Index(vector<bitset<ANUM>> cols, vector<vector<uint64_t>> pids
+        , vector<vector<uint64_t>> off): cols(cols), pids(pids), off(off){
+    this->ncol = cols.size();
+}
+
+void Index::writeToFile(const char* filename){
+    ofstream ofile(filename);
+    uint64_t ncol = cols.size();
+    ofile << ncol << endl;
+
+    //write the vertical partitioning
+    for(auto& c : cols)
+        ofile << c.to_string() << endl;
+
+    //write the horizontal partitioning
+    for(uint64_t i = 0; i < ncol; i++){
+        ofile << pids[i].size() << endl; // the number of h partitions
+        for(uint64_t j = 0; j < pids[i].size(); j++){
+            ofile << pids[i][j] << " " << off[i][j + 1] << endl;
+        }
+    }
+    
+    ofile.close();
+}
+
+Index* Index::readFromFile(const char* filename){
+    ifstream ifile(filename);
+
+    uint64_t ncol;
+    ifile >> ncol;
+    
+    vector<bitset<ANUM>> cols;
+    vector<vector<uint64_t>> pids;
+    vector<vector<uint64_t>> off;
+    cols.reserve(ncol);
+    pids.reserve(ncol);
+    off.reserve(ncol);
+
+    for(uint64_t i = 0; i < ncol; i++){
+        string str;
+        ifile >> str;
+        bitset<ANUM> b(str);
+        cols.push_back(b);
+    }
+
+    for(uint64_t i = 0; i < ncol; i++){
+        uint64_t nrow;
+        ifile >> nrow;
+
+        vector<uint64_t> pv, po;
+        pv.reserve(nrow);
+        po.reserve(nrow + 1);
+        po.push_back(0);
+
+        for(uint64_t j = 0; j < nrow; j++){
+            uint64_t p, of;
+            ifile >> p >> of;
+            pv.push_back(p);
+            po.push_back(of);
+        }
+        pids.push_back(pv);
+        off.push_back(po);
+    }
+
+    ifile.close();
+
+    Index* idx = new Index(cols, pids, off);
+    return idx;
+}
+
+void Index::getColumnVerticalOff(int aid, int& poff, int &voff){
+    poff = 0;
+    for(; poff < cols.size(); poff++){
+        if(cols[poff].test(aid))
+            break;
+    }
+
+    if(poff >= cols.size()){
+        poff = -1;
+        return;
+    }
+
+    voff = 0;
+    for(int i = 0; i < aid; i++)
+        if(cols[poff].test(i))
+            voff++;
+}
+
+void Index::locateCell(uint64_t tid, int aid, uint64_t &pid
+        , uint64_t &hoff, int& voff, int& group_id){
+    this->getColumnVerticalOff(aid, group_id, voff);
+    for(int i = 0; i < pids[group_id].size(); i++){
+        if(off[group_id][i] <= tid && off[group_id][i+1] > tid){
+            pid = pids[group_id][i];
+            hoff = tid - off[group_id][i];
+        }
+    }
+}
+
+void Index::locateRangeCells(uint64_t start_t, uint64_t end_t, int aid
+        , vector<uint64_t>& pid, vector<uint64_t> &hoff_start
+        , vector<uint64_t>& hoff_end, int& voff, int& group_id){
+    pid.clear(); hoff_start.clear(); hoff_end.clear();
+    this->getColumnVerticalOff(aid, group_id, voff);
+    for(int i = 0; i < pids[group_id].size(); i++){
+        uint64_t l(off[group_id][i]), r(off[group_id][i+1]);
+        if(l >= end_t)
+            break;
+        if(r <= start_t)
+            continue;
+        uint64_t start_off = std::max(l, start_t) - l;
+        uint64_t end_off = std::min(end_t, r) - l;
+        pid.push_back(pids[group_id][i]);
+        hoff_start.push_back(start_off);
+        hoff_end.push_back(end_off);
+    }
+}
+
+void Index::locateRangeCells(uint64_t start_t, uint64_t end_t
+            , bitset<ANUM>* attrs, vector<vector<uint64_t>>& pid
+            , vector<vector<uint64_t>>& hoff_start
+            , vector<vector<uint64_t>>& hoff_end
+            , vector<int>& voff, vector<int>& group_id){
+    pid.clear(); hoff_start.clear(); hoff_end.clear();
+    voff.clear(); group_id.clear();
+    vector<int> groups;
+    for(int i = 0; i < ANUM; i++){
+        if(!attrs->test(i))
+            continue;
+        vector<uint64_t> p, hs, he;
+        int v, g;
+
+        this->locateRangeCells(start_t, end_t, i, p, hs, he, v, g);
+        group_id.push_back(g);
+        voff.push_back(v);
+
+        if(find(groups.begin(), groups.end(), g) != groups.end())
+            continue;
+        groups.push_back(g);
+        pid.push_back(p);
+        hoff_start.push_back(hs);
+        hoff_end.push_back(he);
+    }
+}
+
+uint64_t Index::getPartitionNum(){
+    uint64_t num = 0;
+    for(int i = 0; i < pids.size(); i++)
+        for(int j = 0; j < pids[i].size(); j++)
+            num = num > pids[i][j] ? num : pids[i][j];
+    num++;
+    return num;
+}
diff --git a/util/baselines/index.h b/util/baselines/index.h
new file mode 100644
index 0000000..a98839a
--- /dev/null
+++ b/util/baselines/index.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __INDEX__
+#define __INDEX__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <vector>
+#include <bitset>
+
+#include "../partitions/constants.h"
+//#include "../query_evaluator/evaluator.h"
+
+using namespace std;
+
+class Index{
+public:
+    Index(vector<bitset<ANUM>> cols, vector<vector<uint64_t>> pids
+            , vector<vector<uint64_t>> off);
+
+    void writeToFile(const char* filename);
+    
+    //given an attribute, find the column_group and offset in the column
+    //group
+    void getColumnVerticalOff(int aid, int& poff, int& voff);
+    
+    //Given a cell in the table, get the partition id(pid), horizontal 
+    //off set and vertical offset in the partition, and the column group
+    //id of the attribute
+    void locateCell(uint64_t tid, int aid, uint64_t &pid, uint64_t &hoff
+            , int& voff, int& group_id);
+    
+    void locateRangeCells(uint64_t start_t, uint64_t end_t, int aid
+            , vector<uint64_t>& pid, vector<uint64_t> &hoff_start
+            , vector<uint64_t>& hoff_end, int& voff, int& group_id);
+
+    void locateRangeCells(uint64_t start_t, uint64_t end_t
+            , bitset<ANUM>* attrs, vector<vector<uint64_t>>& pid
+            , vector<vector<uint64_t>>& hoff_start
+            , vector<vector<uint64_t>>& hoff_end
+            , vector<int>& voff, vector<int>& group_id);
+
+    //get the total number of partitions
+    uint64_t getPartitionNum();
+
+    static Index* readFromFile(const char* filename);
+
+//private:
+    vector<bitset<ANUM>> cols;
+    vector<vector<uint64_t>> pids;
+    vector<vector<uint64_t>> off;
+
+    uint64_t ncol;
+
+    //friend class IndexIterator;
+};
+
+#endif
diff --git a/util/baselines/partition-direct.cpp b/util/baselines/partition-direct.cpp
new file mode 100644
index 0000000..0f3fbd8
--- /dev/null
+++ b/util/baselines/partition-direct.cpp
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "partition.h"
+#include "../partitions/profiler.h"
+
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <math.h>
+
+#include <fstream>
+#include <string>
+#include <string.h>
+
+template<typename T>
+Partition<T>::Partition(uint64_t pid, bitset<ANUM> cols
+        , T* data, uint64_t data_num){
+    this->pid = pid;
+//    this->rid = rid;
+    this->cols = cols;
+    this->data = data;
+    this->ncol = this->cols.count();
+    this->nrow = data_num / this->ncol;
+    this->buf = NULL;
+
+
+    //col_off
+    int t = 0;
+    for(int i = 0; i < ANUM; i++){
+        col_off[i] = -1;
+        if(this->cols[i] == 1)
+            col_off[i] = t++;
+    }
+}
+
+template<typename T>
+Partition<T>::Partition(char* buf, uint64_t len){
+    char* ptr = buf;
+
+    this->pid = *((uint64_t*)ptr);
+    ptr += sizeof(this->pid);
+
+    //this->rid = *((uint64_t*)ptr);
+    //ptr += sizeof(this->rid);
+
+    this->nrow = *((uint64_t*)ptr);
+    ptr += sizeof(this->nrow);
+
+    string s(ptr, ANUM);
+    bitset<ANUM> b(s);
+    this->cols = b;
+    this->ncol = this->cols.count();
+    ptr += ANUM;
+
+    this->data = (T*)ptr;
+    this->buf = buf;
+
+    //col_off
+    int t = 0;
+    for(int i = 0; i < ANUM; i++){
+        col_off[i] = -1;
+        if(this->cols[i] == 1)
+            col_off[i] = t++;
+    }
+
+}
+
+template<typename T>
+Partition<T>::~Partition(){
+    if(this->buf)
+        //delete[] this->buf;
+        free(this->buf);
+}
+
+template<typename T>
+int Partition<T>::writeToFile(const char* filename){
+    uint64_t buf_size = sizeof(uint64_t) * 2 //pid, nrow
+        + ANUM + sizeof(T) * nrow * ncol;
+
+    char* buf = new char[buf_size];
+
+    uint64_t c = 0;
+    memcpy(buf + c, &this->pid, sizeof(this->pid));
+    c += sizeof(this->pid);
+
+    //memcpy(buf + c, &this->rid, sizeof(this->rid));
+    //c += sizeof(this->rid);
+
+    memcpy(buf + c, &this->nrow, sizeof(this->nrow));
+    c += sizeof(this->nrow);
+
+    memcpy(buf + c, this->cols.to_string().c_str(), ANUM);
+    c += ANUM;
+
+    memcpy(buf + c, this->data, sizeof(T)*nrow*ncol);
+    c += sizeof(T)*nrow*ncol;
+
+    
+    ofstream ofile(filename, ios::binary);
+    ofile.write(buf, c);
+    ofile.close();
+
+    delete[] buf;
+}
+
+
+Profiler io_profiler[128];
+
+template<typename T>
+Partition<T>* Partition<T>::readFromFile(unsigned short threadid
+        , const char* filename){
+    //printf("Direct");
+    io_profiler[threadid].start_timer();
+    
+    struct stat st;
+    stat(filename, &st); 
+    uint64_t size = st.st_size;
+    //char* buf = new char[size];
+    char* buf;
+    uint64_t buf_size = ceil(size/4096.0) * 4096;
+    posix_memalign((void**)&buf, 4096, buf_size);
+    
+    int fid = open(filename, O_RDONLY | O_DIRECT);
+    char* ptr = buf;
+    uint64_t res_len = size;
+    uint64_t buf_res_len = buf_size;
+    
+    while(res_len != 0){
+        ssize_t read_len = read(fid, ptr, buf_res_len);
+        ptr += read_len;
+        res_len -= read_len;
+        buf_res_len -= read_len;
+        if(read_len < 0){
+            printf("Value of errorno: %d\n", errno);
+            printf("Error name: %s\n", strerror(errno));
+            free(buf);
+            return NULL;
+        }
+        
+    }
+    close(fid);    
+
+    Partition<T>* part = new Partition<T>(buf, size);
+    
+    io_profiler[threadid].stop_timer();
+    io_profiler[threadid].add_io_size(size);
+    
+    return part;
+}
+
+template class Partition<VTYPE>;
diff --git a/util/baselines/partition.cpp b/util/baselines/partition.cpp
new file mode 100644
index 0000000..c16606c
--- /dev/null
+++ b/util/baselines/partition.cpp
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "partition.h"
+#include "../partitions/profiler.h"
+
+#include <fstream>
+#include <string>
+#include <string.h>
+
+template<typename T>
+Partition<T>::Partition(uint64_t pid, bitset<ANUM> cols
+        , T* data, uint64_t data_num){
+    this->pid = pid;
+//    this->rid = rid;
+    this->cols = cols;
+    this->data = data;
+    this->ncol = this->cols.count();
+    this->nrow = data_num / this->ncol;
+    this->buf = NULL;
+
+
+    //col_off
+    int t = 0;
+    for(int i = 0; i < ANUM; i++){
+        col_off[i] = -1;
+        if(this->cols[i] == 1)
+            col_off[i] = t++;
+    }
+}
+
+template<typename T>
+Partition<T>::Partition(char* buf, uint64_t len){
+    char* ptr = buf;
+
+    this->pid = *((uint64_t*)ptr);
+    ptr += sizeof(this->pid);
+
+    //this->rid = *((uint64_t*)ptr);
+    //ptr += sizeof(this->rid);
+
+    this->nrow = *((uint64_t*)ptr);
+    ptr += sizeof(this->nrow);
+
+    string s(ptr, ANUM);
+    bitset<ANUM> b(s);
+    this->cols = b;
+    this->ncol = this->cols.count();
+    ptr += ANUM;
+
+    this->data = (T*)ptr;
+    this->buf = buf;
+
+    //col_off
+    int t = 0;
+    for(int i = 0; i < ANUM; i++){
+        col_off[i] = -1;
+        if(this->cols[i] == 1)
+            col_off[i] = t++;
+    }
+
+}
+
+template<typename T>
+Partition<T>::~Partition(){
+    if(this->buf)
+        delete[] this->buf;
+}
+
+template<typename T>
+int Partition<T>::writeToFile(const char* filename){
+    uint64_t buf_size = sizeof(uint64_t) * 2 //pid, nrow
+        + ANUM + sizeof(T) * nrow * ncol;
+
+    char* buf = new char[buf_size];
+
+    uint64_t c = 0;
+    memcpy(buf + c, &this->pid, sizeof(this->pid));
+    c += sizeof(this->pid);
+
+    //memcpy(buf + c, &this->rid, sizeof(this->rid));
+    //c += sizeof(this->rid);
+
+    memcpy(buf + c, &this->nrow, sizeof(this->nrow));
+    c += sizeof(this->nrow);
+
+    memcpy(buf + c, this->cols.to_string().c_str(), ANUM);
+    c += ANUM;
+
+    memcpy(buf + c, this->data, sizeof(T)*nrow*ncol);
+    c += sizeof(T)*nrow*ncol;
+
+    
+    ofstream ofile(filename, ios::binary);
+    ofile.write(buf, c);
+    ofile.close();
+
+    delete[] buf;
+}
+
+
+Profiler io_profiler[128];
+
+template<typename T>
+Partition<T>* Partition<T>::readFromFile(unsigned short threadid
+        , const char* filename){
+    
+    io_profiler[threadid].start_timer();
+
+    ifstream ifile(filename, ios::binary);
+    
+    streampos begin, end;
+    begin = ifile.tellg();
+    ifile.seekg(0, ios::end);
+    end = ifile.tellg();
+
+    uint64_t size = end - begin;
+    char* buf = new char[size];
+    ifile.seekg(0, ios::beg);
+    ifile.read(buf, size);
+    
+    if(ifile.gcount() != size){
+        delete[] buf;
+        ifile.close();
+        return NULL;
+    }
+
+    ifile.close();
+
+    Partition<T>* part = new Partition<T>(buf, size);
+    
+    io_profiler[threadid].stop_timer();
+    io_profiler[threadid].add_io_size(size);
+    
+    return part;
+}
+
+template class Partition<VTYPE>;
diff --git a/util/baselines/partition.h b/util/baselines/partition.h
new file mode 100644
index 0000000..4f22f72
--- /dev/null
+++ b/util/baselines/partition.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PARTITION__
+#define __PARTITION__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <bitset>
+
+#include "../partitions/constants.h"
+
+using namespace std;
+
+template<typename T>
+class Partition{
+
+private:
+    uint64_t pid;
+    //uint64_t rid; // the order in rows
+    bitset<ANUM> cols;
+    int col_off[ANUM];
+    uint64_t ncol;
+    uint64_t nrow;
+    T* data;
+
+    char* buf;
+
+public:
+    Partition(uint64_t pid, bitset<ANUM> cols, T* data
+            , uint64_t data_num);
+    Partition(char* buf, uint64_t len);
+
+    ~Partition();
+
+    /*
+     * col_id is the attribute ID of the column
+     * off is the order of the tuple in the partition
+     */
+    T getData(uint64_t col_id, uint64_t off);
+    
+    T* getAllData(uint64_t &len, uint64_t& tsize){
+        tsize = sizeof(T) * ncol;
+        len = tsize * nrow;
+        return data;
+    }
+
+    uint64_t getPID();
+   
+    int writeToFile(const char* filename); 
+    static Partition<T>* readFromFile(unsigned short threadid
+            , const char* filename);
+
+};
+
+template<typename T>
+inline T Partition<T>::getData(uint64_t col_id, uint64_t off){
+    return data[off*ncol + col_off[col_id]];
+}
+
+template<typename T>
+inline uint64_t Partition<T>::getPID(){
+    return pid;
+}
+
+#endif
diff --git a/util/baselines/tablecolumn.cpp b/util/baselines/tablecolumn.cpp
new file mode 100644
index 0000000..927b68c
--- /dev/null
+++ b/util/baselines/tablecolumn.cpp
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "tablecolumn.h"
+#include <vector>
+
+#include <iostream>
+
+TableColumn::TableColumn(string data_dir, Index* index, int thread_num 
+            , bitset<ANUM>* attrs, bitset<TNUM>* tuples){
+
+    vector<int> aoff;
+    vector<uint64_t> poff;
+
+    uint64_t part_per_column = index->pids[0].size();
+    for(int i = 0; i < ANUM; i++)
+        if(attrs->test(i))
+            aoff.push_back(i);
+    
+    if(tuples == NULL){
+        for(uint64_t i = 0; i < part_per_column; i++){
+            poff.push_back(i);
+            this->row_off.push_back(index->off[0][i]);
+        }
+    }else{
+        for(uint64_t i = 0; i < part_per_column; i++){
+            //partitions are horizontally aligned
+            uint64_t start = index->off[0][i];
+            uint64_t end = index->off[0][i+1];
+
+            for(uint64_t j = start; j < end; j++){
+                if(tuples->test(j)){
+                    poff.push_back(i);
+                    this->row_off.push_back(start);
+                    break;
+                }
+            }
+        }
+    } 
+
+    for(auto i : poff){
+        vector<uint64_t> v;
+        for(auto a : aoff)
+            v.push_back(index->pids[a][i]);
+        pids.push_back(v);
+    }
+
+    this->data_dir = data_dir;
+    this->thread_num = thread_num;
+    next_off = new uint64_t[thread_num];
+    for(int i = 0 ; i < thread_num; i++){
+        next_off[i] = i;
+        //partitions.push_back(vector<Partition<VTYPE>*>());
+    }
+}
+
+bool TableColumn::atomicGetNext(int thread_id
+        , vector<Partition<VTYPE>*>& partitions
+        , uint64_t &row_off){
+    partitions.clear();
+    //for(int i = 0; i < this->partitions[thread_id].size(); i++)
+    //    delete this->partitions[thread_id][i];
+    
+
+    if(next_off[thread_id] >= pids.size())
+        return false;
+
+    for(auto p : pids[next_off[thread_id]]){
+        string path = data_dir + "/" + std::to_string(p);
+        Partition<VTYPE>* part = Partition<VTYPE>::
+            readFromFile(thread_id, path.c_str());
+        partitions.push_back(part);
+    }
+    //this->partitions[thread_id] = partitions;
+    
+    //cout << partitions[0]->getPID() << endl;
+
+    row_off = this->row_off[next_off[thread_id]];
+    next_off[thread_id] += thread_num;
+    return true;
+}
+
+TableColumn::~TableColumn(){
+    delete[] next_off;
+    /*for(int i = 0; i < thread_num; i++)
+        for(int j = 0; j < partitions[i].size(); j++)
+            delete partitions[i][j];*/
+}
diff --git a/util/baselines/tablecolumn.h b/util/baselines/tablecolumn.h
new file mode 100644
index 0000000..4222d60
--- /dev/null
+++ b/util/baselines/tablecolumn.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __TABLECOLUMN__
+#define __TABLECOLUMN__
+
+#include <bitset>
+#include <cstdint>
+#include <string>
+
+#include "../partitions/constants.h"
+#include "index.h"
+#include "partition.h"
+
+using namespace std;
+
+class TableColumn{
+
+public:
+    TableColumn(string data_dir, Index* index, int thread_num = 1
+            , bitset<ANUM>* attrs = NULL, bitset<TNUM>* tuples = NULL);
+    bool atomicGetNext(int thread_id
+            , vector<Partition<VTYPE>*> &partitions
+            , uint64_t &row_off);
+
+    ~TableColumn();
+
+public:
+    vector<vector<uint64_t>> pids;
+    vector<uint64_t> row_off;
+    int thread_num;
+    uint64_t* next_off;
+    //vector<vector<Partition<VTYPE>*>> partitions;
+    string data_dir;
+};
+
+#endif
diff --git a/util/baselines/tablerow.cpp b/util/baselines/tablerow.cpp
new file mode 100644
index 0000000..6803877
--- /dev/null
+++ b/util/baselines/tablerow.cpp
@@ -0,0 +1,198 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "tablerow.h"
+#include <set>
+#include <algorithm>
+#include <iostream>
+
+TableRow::TableRow(string data_dir, Index* index, int thread_num
+        , bitset<ANUM>* attrs){
+    
+    int pnum = index->getPartitionNum();
+    for(uint64_t i = 0; i < pnum; i++){
+        count_all.push_back(0);
+        count_complete.push_back(0);
+        buffer.push_back(NULL);
+        locks.push_back(Lock());
+    }
+    
+    uint64_t len_per_thread = TNUM / thread_num;
+    for(int t = 0; t < thread_num; t++){
+        uint64_t start = len_per_thread * t;
+        uint64_t end = start + len_per_thread;
+        if(thread_num == t + 1)
+            end = TNUM;
+        tuple_ranges.push_back(start);
+        thread_cur.push_back(start);
+        thread_last.push_back(-1);
+
+       
+        vector<vector<uint64_t>> pid, hs, he;
+        vector<int> voff, group_id;
+        index->locateRangeCells(start, end, attrs, pid, hs, he
+                , voff, group_id);
+
+        for(int i = 0; i < pid.size(); i++)
+            for(int j = 0; j < pid[i].size(); j++)
+                count_all[pid[i][j]]++;
+
+    }
+    tuple_ranges.push_back(TNUM);
+
+    this->attrs = attrs;
+    this->index = index;
+    this->data_dir = data_dir;
+}
+
+TableRow::~TableRow(){
+    for(const auto& p : buffer)
+        if(p != NULL)
+            delete p;
+}
+
+void TableRow::getColumnOff(vector<int>& poff, vector<int>& voff){
+    poff.clear();
+    voff.clear();
+
+    vector<int> group_id;
+
+    for(int i = 0; i < ANUM; i++)
+        if(attrs->test(i)){
+            uint64_t pid, hoff;
+            int v, g;
+            index->locateCell(0, i, pid, hoff, v, g);
+            voff.push_back(v);
+            poff.push_back(g);
+            if(find(group_id.begin(), group_id.end(), g) == 
+                    group_id.end())
+                group_id.push_back(g);
+        }
+
+    for(int i = 0; i < poff.size(); i++)
+        for(int j = 0; j < group_id.size(); j++)
+            if(poff[i] == group_id[j]){
+                poff[i] = j;
+                break;
+            }
+    
+}
+
+void TableRow::complete(uint64_t pid){
+    locks[pid].lock();
+    count_complete[pid]++;
+    //all threads have finished the partition
+    if(count_complete[pid] == count_all[pid]){
+        delete buffer[pid];
+        buffer[pid] = NULL;
+    }
+    locks[pid].unlock();
+}
+
+Partition<VTYPE>* TableRow::getPartition(unsigned short threadid
+        , uint64_t pid){
+    //cout << pid << endl;
+    locks[pid].lock();
+    Partition<VTYPE>* ret = buffer[pid];
+    if(ret == NULL){
+        string path = data_dir + "/" + std::to_string(pid);
+        ret = Partition<VTYPE>::readFromFile(threadid, path.c_str());
+        buffer[pid] = ret;
+    }
+    locks[pid].unlock();
+    return ret;
+}
+
+TableRow::SubTable* TableRow::atomicGetNext(int t, uint64_t &row_num){
+    
+    if(thread_cur[t] >= tuple_ranges[t+1])
+        return NULL;
+    vector<vector<uint64_t>> last_pid, hoff_start, hoff_end;
+    vector<int> voff, group_id;
+    if(thread_last[t] != -1){
+        index->locateRangeCells(thread_last[t], thread_last[t] 
+                + tuples_per_next, attrs, last_pid, hoff_start
+                , hoff_end, voff, group_id);
+    }
+    vector<vector<uint64_t>> pids;
+    uint64_t end = min(thread_cur[t] + tuples_per_next
+            , tuple_ranges[t+1]);
+    index->locateRangeCells(thread_cur[t], end, attrs, pids, hoff_start
+            , hoff_end, voff, group_id);
+    
+    //complete the last scanned partitions
+    for(const auto& lgp : last_pid)
+        for(auto lp : lgp){
+            bool exist = false;
+            for(const auto& gp : pids){
+                for(auto p : gp)
+                    if(p == lp){
+                        exist = true;
+                        break;
+                    }
+                if(exist)
+                    break;
+            }
+            if(!exist)
+                complete(lp);
+        }
+
+    //request the partitions
+    vector<vector<Partition<VTYPE>*>> ret_partitions;
+    for(int i = 0; i < pids.size(); i++){
+        ret_partitions.push_back(vector<Partition<VTYPE>*>());
+        for(int j = 0; j < pids[i].size(); j++){
+            Partition<VTYPE>* p = getPartition(t, pids[i][j]);
+            ret_partitions[i].push_back(p);
+        }
+    }
+
+    SubTable* ret = new SubTable(ret_partitions, hoff_start, hoff_end);
+
+    thread_last[t] = thread_cur[t];
+    thread_cur[t] = end;
+    row_num = thread_cur[t] - thread_last[t];
+    return ret;
+}
+
+TableRow::SubTable::SubTable(vector<vector<Partition<VTYPE>*>> &part
+        , vector<vector<uint64_t>>& start
+        , vector<vector<uint64_t>>& end){
+    partitions = part;
+    this->start = start;
+    this->end = end;
+
+    for(int i = 0; i < partitions.size(); i++){
+        pcur.push_back(0);
+        tcur.push_back(start[i][0]);
+    }
+}
diff --git a/util/baselines/tablerow.h b/util/baselines/tablerow.h
new file mode 100644
index 0000000..f75f9d9
--- /dev/null
+++ b/util/baselines/tablerow.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __TABLEROW__
+#define __TABLEROW__
+
+#include "../../lock.h"
+#include "../partitions/constants.h"
+#include "index.h"
+#include "partition.h"
+
+#include <vector>
+using namespace std;
+
+class TableRow{
+
+public:
+    TableRow(string data_dir, Index* index, int thread_num
+            , bitset<ANUM>* attrs);
+   
+    //get the vertical offset of the select attribute
+    //the poff is the offset of the partition containing an attribute
+    //voff is the offset of the attribute in the partition 
+    void getColumnOff(vector<int>& poff, vector<int>& voff);
+
+    class SubTable{
+    public:
+
+        SubTable(vector<vector<Partition<VTYPE>*>> &part
+                , vector<vector<uint64_t>>& start
+                , vector<vector<uint64_t>>& end);
+
+        inline bool getNext(vector<Partition<VTYPE>*>& part
+                , vector<uint64_t> &off);
+
+        vector<vector<Partition<VTYPE>*>> partitions;
+        vector<vector<uint64_t>> start;
+        vector<vector<uint64_t>> end;
+    private:
+        vector<int> pcur;
+        vector<uint64_t> tcur;
+    };
+
+    SubTable* atomicGetNext(int thread_id, uint64_t &row_num);
+    
+    ~TableRow();
+
+    static const int tuples_per_next = 1024*1024;
+
+private:
+
+    void complete(uint64_t pid);
+    Partition<VTYPE>* getPartition(unsigned short threadid, uint64_t pid);
+
+    vector<uint64_t> tuple_ranges;
+    vector<uint64_t> thread_cur;
+    vector<int64_t> thread_last;
+    
+    vector<int> count_all;
+    vector<int> count_complete;
+    vector<Partition<VTYPE>*> buffer;
+    vector<Lock> locks;
+
+    bitset<ANUM>* attrs;
+    Index* index;
+    string data_dir;
+
+};
+
+inline bool TableRow::SubTable::getNext(vector<Partition<VTYPE>*>& part
+        , vector<uint64_t>& off){
+    part.clear();
+    off.clear();
+    for(int i = 0; i < pcur.size(); i++){
+        if(tcur[i] >= end[i][pcur[i]]){
+            pcur[i]++;
+            if(pcur[i] >= partitions[i].size())
+                return false;
+            tcur[i] = start[i][pcur[i]];
+        }
+        part.push_back(partitions[i][pcur[i]]);
+        off.push_back(tcur[i]);
+        tcur[i]++;
+    }
+    return true;
+}
+
+#endif
diff --git a/util/hashtable.h b/util/hashtable.h
index 21ecfc2..8b225c3 100644
--- a/util/hashtable.h
+++ b/util/hashtable.h
@@ -31,6 +31,9 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#ifndef __HASHTABLE__
+#define __HASHTABLE__
+
 #include "../lock.h"
 #include "custom_asserts.h"
 #include "static_assert.h"
@@ -231,23 +234,33 @@ class HashTable {
 		 */
 		inline void lockbucket(unsigned int offset)
 		{
-			BucketHeader* bh = getBucketHeader(offset);
+            BucketHeader* bh = getBucketHeader(offset);
 			dbgassert(*(unsigned long long*)bh != 0xBCBCBCBCBCBCBCBCuLL);
 			bh->lock.lock();
 		}
+		
+        /**
+		 * Try to Locks bucket
+         * Return true if the bucket is locked
+		 */
+		inline bool trylockbucket(unsigned int offset)
+		{
+            BucketHeader* bh = getBucketHeader(offset);
+			dbgassert(*(unsigned long long*)bh != 0xBCBCBCBCBCBCBCBCuLL);
+			return bh->lock.trylock();
+		}
 
 		/**
 		 * Locks bucket. Call blocks until spinlock is held.
 		 */
 		inline void unlockbucket(unsigned int offset)
 		{
-			BucketHeader* bh = getBucketHeader(offset);
+            BucketHeader* bh = getBucketHeader(offset);
 			dbgassert(*(unsigned long long*)bh != 0xBCBCBCBCBCBCBCBCuLL);
 			bh->lock.unlock();
 		}
 
-
-	private:
+	protected:
 		static const unsigned int MAX_PART = 4;
 		void* bucket[MAX_PART];
 
@@ -297,3 +310,5 @@ class HashTable {
 			return ret;
 		}
 };
+
+#endif
diff --git a/util/numaallocate.cpp b/util/numaallocate.cpp
index 01398c7..10daab3 100644
--- a/util/numaallocate.cpp
+++ b/util/numaallocate.cpp
@@ -368,17 +368,32 @@ void* lookaside_init_alloc(size_t allocsize, int node)
 }
 
 void* Lookaside::arena[MAX_NUMA] = {
-	lookaside_init_alloc(1uLL*1024*1024*1024, 0),
-	lookaside_init_alloc(1uLL*1024*1024*1024, 1),
-	lookaside_init_alloc(1uLL*1024*1024*1024, 2),
-	lookaside_init_alloc(1uLL*1024*1024*1024, 3),
-	lookaside_init_alloc(1uLL*1024*1024*1024, 4),
-	lookaside_init_alloc(1uLL*1024*1024*1024, 5),
-	lookaside_init_alloc(1uLL*1024*1024*1024, 6),
-	lookaside_init_alloc(1uLL*1024*1024*1024, 7)
+	lookaside_init_alloc(8uLL*1024*1024*1024, 0),
+	lookaside_init_alloc(1uLL*1024*1024, 1),
+	lookaside_init_alloc(1uLL*1024*1024, 2),
+	lookaside_init_alloc(1uLL*1024*1024, 3),
+	lookaside_init_alloc(1uLL*1024*1024, 4),
+	lookaside_init_alloc(1uLL*1024*1024, 5),
+	lookaside_init_alloc(1uLL*1024*1024, 6),
+	lookaside_init_alloc(1uLL*1024*1024, 7)
 };
 static_assert(MAX_NUMA == 8);	// need to add functions above, otherwise.
 
+void numaclearlookaside(){
+    size_t s_max = 8uLL*1024*1024*1024;
+    size_t s_min = 1uLL*1024*1024;
+    
+    size_t alloc_size[MAX_NUMA] = {s_max, s_min, s_min, s_min, s_min
+        , s_min, s_min, s_min};
+    for(int i = 0; i < MAX_NUMA; i++){
+        LookasideHeader* lh = (LookasideHeader*) Lookaside::arena[i];
+        if(lh != NULL){
+            lh->free = &lh[1];
+            lh->maxsize = alloc_size[i] - sizeof(LookasideHeader);
+        }
+    }
+}
+
 /**
  * Function does allocation via mmap().
  *
@@ -585,6 +600,7 @@ void* numaallocate_onnode(const char tag[4], size_t allocsize, int node, void* s
 
 	if (memory == NULL)
 	{
+		printf("**Error: %s called slowallocate\n", tag);
 		memory = slowallocate_onnode(tag, allocsize, node, source);
 	}
 	assert((((unsigned long long)memory) & 0x7) == 0);
diff --git a/util/numaallocate.h b/util/numaallocate.h
index 6055f91..b6828dc 100644
--- a/util/numaallocate.h
+++ b/util/numaallocate.h
@@ -37,3 +37,5 @@ void* numaallocate_onnode(const char tag[4], size_t allocsize, int node, void* s
 void numadeallocate(void* space);
 void accountfordealloc(size_t allocsize);
 void accountforalloc(size_t allocsize);
+
+void numaclearlookaside();
diff --git a/util/partitions/constants.h b/util/partitions/constants.h
new file mode 100644
index 0000000..e704e94
--- /dev/null
+++ b/util/partitions/constants.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdlib.h>
+#include <stdio.h>
+
+#ifndef CONSTANTS
+#define CONSTANTS
+
+
+#define VTYPE int
+#define ANUM 160
+#define QNUM 100
+#define TNUM 100000000
+
+const VTYPE INVALID_VALUE = -9999;
+
+//#define PERF
+
+#endif
diff --git a/util/partitions/hashtabledelete.cpp b/util/partitions/hashtabledelete.cpp
new file mode 100644
index 0000000..22b2b0c
--- /dev/null
+++ b/util/partitions/hashtabledelete.cpp
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "hashtabledelete.h"
+#include <string.h>
+
+void HashTableD::atomicDelete(unsigned int offset, unsigned int slot){
+    BucketHeader* bh = getBucketHeader(offset);
+    dbgassert(*(unsigned long long*)bh != 0xBCBCBCBCBCBCBCBCuLL);
+    bh->lock.lock();
+    
+    this->Delete(offset, slot);
+
+    bh->lock.unlock();
+}
+
+void HashTableD::Delete(unsigned int offset, unsigned int slot){
+   
+    BucketHeader* bh = getBucketHeader(offset);
+    BucketHeader* it = bh; 
+    BucketHeader* it_prev = NULL;
+    unsigned int i = 0;
+    while(it != NULL){
+        unsigned int snum = it->used / tuplesize;
+        if(i + snum > slot)
+            break;
+        i += snum;
+        it_prev = it;
+        it = it->nextBucket;
+    }
+
+    if(it == NULL){
+        bh->lock.unlock();
+        return;
+    }
+    
+    //find the loc to delete
+    void* loc = ((char*)it + sizeof(BucketHeader))
+                    + (slot - i) * tuplesize;
+    
+    //find the last bucket and last slot
+    BucketHeader* last_bucket = it;
+    BucketHeader* second_last = it_prev;
+    while(last_bucket->nextBucket != NULL){
+        second_last = last_bucket;
+        last_bucket = last_bucket->nextBucket;
+    }
+    void* last_slot = ((char*)last_bucket + sizeof(BucketHeader))
+                    + last_bucket->used - tuplesize;
+
+    //copy the last slot to the loc
+    if(last_slot != loc)
+        memcpy(loc, last_slot, tuplesize);
+    
+    //delete the last slot
+    last_bucket->used -= tuplesize;
+
+    //delete the last bucket if it is empty
+    if(last_bucket->used == 0 && second_last != NULL){
+        numadeallocate(last_bucket);
+        second_last->nextBucket = 0;
+    }
+        
+}
diff --git a/util/partitions/hashtabledelete.h b/util/partitions/hashtabledelete.h
new file mode 100644
index 0000000..4842b3c
--- /dev/null
+++ b/util/partitions/hashtabledelete.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __HASHTABLED__
+#define __HASHTABLED__
+
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+
+#include "../hashtable.h"
+
+class HashTableD : public HashTable{
+
+public:
+    friend class PrettyPrinterVisitor;
+
+    HashTableD(): HashTable() {}
+
+    void atomicDelete(unsigned int offset, unsigned int slot);
+
+    void Delete(unsigned int offset, unsigned int slot);
+
+};
+
+#endif
diff --git a/util/partitions/index.cc b/util/partitions/index.cc
new file mode 100644
index 0000000..28c52a9
--- /dev/null
+++ b/util/partitions/index.cc
@@ -0,0 +1,232 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <sstream>
+#include "index.h"
+#include "partition.h"
+
+Index::Index(uint64_t p_num, vector<vector<int> > *attr_index,
+		vector<vector<int> > *schema_index, vector<TupleIndex> *tuple_index) {
+	this->p_num = p_num;
+	this->attr_index = attr_index;
+	this->schema_index = schema_index;
+	this->tuple_index = tuple_index;
+	this->t_num = tuple_index->size();
+}
+
+/*
+void Index::serialize(string filename) {
+	uint64_t size = sizeof(uint64_t); // p_num
+	for (int i = 0; i < ANUM; i++) {
+		size += sizeof(int);	//# of attr value
+		size += attr_index[i].size() * sizeof(int);
+	}
+	size += sizeof(int);	//# of schema_index
+	for (int i = 0; i < schema_index.size(); i++) {
+		size += ANUM * sizeof(int);
+	}
+	for (int i = 0; i < TNUM; i++) {
+		size += sizeof(int);
+		size += sizeof(int);
+		size += tuple_index[i].second.size() * sizeof(int);
+	}
+
+	// write to buffer
+
+	char *buffer = new char[size];
+	uint64_t c = 0;
+	memcpy(buffer + c, &p_num, sizeof(uint64_t));
+	c += sizeof(uint64_t);
+
+	for (int i = 0; i < ANUM; i++) {
+		int v_size = attr_index[i].size();
+		memcpy(buffer + c, &v_size, sizeof(int));
+		c += sizeof(int);
+		memcpy(buffer + c, attr_index[i].data(), v_size * sizeof(int));
+		c += v_size * sizeof(int);
+	}
+
+	int schema_index_size = schema_index.size();
+	memcpy(buffer + c, &schema_index_size, sizeof(int));
+	c += sizeof(int);
+
+	for (int i = 0; i < schema_index_size; i++) {	
+		memcpy(buffer + c, schema_index[i].data(), ANUM * sizeof(int));
+		c += ANUM * sizeof(int);	
+	}
+	for (int i = 0; i < TNUM; i++) {
+		int schema_id = tuple_index[i].first;
+		memcpy(buffer + c, &schema_id, sizeof(int));
+		c += sizeof(int);
+
+		int t_size = tuple_index[i].second.size();
+		memcpy(buffer + c, &t_size, sizeof(int));
+		c += sizeof(int);
+
+		memcpy(buffer + c, tuple_index[i].second.data(), t_size * sizeof(int));
+		c += t_size * sizeof(int);
+	}
+	ofstream outfile(filename.c_str(), ios::binary);
+	outfile.write(buffer, size);
+	outfile.close();
+	delete[] buffer;
+}
+*/
+
+Index * Index::deserialize(string filename) {
+	ifstream infile(filename.c_str(), ios::binary);
+	infile.seekg(0, ios::end);
+	size_t size = infile.tellg();
+	infile.seekg(0, ios::beg);
+
+	char *buffer = new char[size];
+	char *c = buffer;
+	infile.read(buffer, size);
+    if(infile.gcount() != size){
+        infile.close();
+        cout << "initialize error" << endl;
+    }
+    // infile.close();
+
+    vector<vector<int> >* attr_index = new vector<vector<int> >(ANUM);
+
+    int p_num = *(uint64_t*)c;
+    c += sizeof(uint64_t);
+
+    for (int i = 0; i < ANUM; i++) {
+    	int v_size = *(int*)c;
+    	c += sizeof(int);
+    	vector<int> attr(v_size);
+    	for (int j = 0; j < v_size; j++) {
+    		attr[j] = *(int*)c;
+    		c += sizeof(int);
+    	}
+    	attr_index->at(i) = attr;
+    }
+
+    int schema_index_size = *(int*)c;
+    vector<vector<int> >* schema_index = new vector<vector<int> >(schema_index_size);
+    c += sizeof(int);
+    for (int i = 0; i < schema_index_size; i++) {
+    	int s_size = ANUM;
+
+    	vector<int> schema(ANUM);
+    	for (int j = 0; j < s_size; j++) {
+    		schema[j] = *(int*)c;
+    		c += sizeof(int);
+    	}
+    	schema_index->at(i) = schema;
+    }
+
+    uint64_t tuple_start_pos = c - buffer;
+    delete[] buffer;
+    
+
+    vector<TupleIndex>* tuple_index = new vector<TupleIndex>(TNUM);
+    uint64_t tuple_buffer_size = 3000 * sizeof(int);
+    char* tuple_buffer = new char[tuple_buffer_size];
+
+    for (uint64_t i = 0; i < TNUM; i++) {
+    	infile.seekg(tuple_start_pos, ios::beg);
+    	uint64_t s = min(size - tuple_start_pos + 1, tuple_buffer_size);
+    	infile.read(tuple_buffer, s);
+
+    	char* tuple_c = tuple_buffer;
+
+    	int schema_id = *(int*)tuple_c;
+    	tuple_c += sizeof(int);
+    	
+    	int p_num = *(int*)tuple_c;
+    	tuple_c += sizeof(int);
+
+    	vector<int> partitions(p_num);
+    	for (int j = 0; j < p_num; j++) {
+    		partitions[j] = *(int*)tuple_c;
+    		tuple_c += sizeof(int);
+    	}
+    	TupleIndex tindex = make_pair(schema_id, partitions);
+    	tuple_index->at(i) = tindex;
+
+    	tuple_start_pos += tuple_c - tuple_buffer;
+    	
+    }
+    delete[] tuple_buffer;
+    infile.close();
+
+    return new Index(p_num, attr_index, schema_index, tuple_index);
+}
+
+set<int> Index::getPartitionByAttr(vector<int>attrs) {
+	set<int> re;
+	for (int i = 0; i < attrs.size(); i++) {
+		vector<int> p_ids = attr_index->at(attrs[i]);
+		for (int j = 0; j < p_ids.size(); j++) {
+			re.insert(p_ids[j]);
+		}
+	}
+	return re;
+}
+/*
+string Index::to_string() {
+	stringstream buffer;
+	buffer << "attr_index: " << endl;
+	for (int i = 0; i < attr_index.size(); i++) {
+		buffer << "\tattr: " << i <<endl;
+		buffer << "\t\t";
+		for (int j = 0; j < attr_index[i].size(); j++) {
+			buffer << attr_index[i][j] << ",";
+		}
+		buffer << endl;
+	}
+	buffer << "schema_index: " << endl;
+	for (int i = 0; i < schema_index.size(); i++) {
+		buffer << "\tschema: " << i <<endl;
+		buffer << "\t\t";
+		for (int j = 0; j < schema_index[i].size(); j++) {
+			buffer << schema_index[i][j] << ",";
+		}
+		buffer << endl;
+	}
+	buffer << "tuple_index: " << endl; 
+	for (int i = 0; i < tuple_index.size(); i++) {
+		buffer << "\t";
+		buffer << "t_id: " << i  << ", schema:" << tuple_index[i].first <<endl;
+		buffer << "\tpartitions: " << endl;
+		buffer << "\t\t";
+		for (int j = 0; j < tuple_index[i].second.size(); j++) {
+			buffer << tuple_index[i].second[j] << ",";
+		}
+		buffer << endl;
+	}
+	return buffer.str();
+}
+*/
\ No newline at end of file
diff --git a/util/partitions/index.h b/util/partitions/index.h
new file mode 100644
index 0000000..8d682e2
--- /dev/null
+++ b/util/partitions/index.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef INDEX
+#define INDEX
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <vector>
+#include <string>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <iostream>
+#include <fstream>
+#include <unistd.h>
+#include <cstring>
+#include <set>
+#include <utility>
+#include "constants.h"
+using namespace std;
+
+typedef pair<int, vector<int> > TupleIndex;
+
+class Index {
+public:
+	vector<vector<int> > *attr_index;
+	vector<vector<int> > *schema_index;
+	vector<TupleIndex> *tuple_index;
+	uint64_t p_num;
+	uint64_t t_num;
+
+	Index(uint64_t p_num, vector<vector<int> > *attr_index,
+		vector<vector<int> > *schema_index, vector<TupleIndex> *tuple_index);
+
+	// void serialize(string filename);
+	static Index *deserialize(string filename);
+
+	set<int> getPartitionByAttr(vector<int>attrs);
+	int getPartitionByCell(uint64_t tid, int aid);
+
+	// string to_string();
+};
+
+inline int Index::getPartitionByCell(uint64_t tid, int aid){
+    int s = tuple_index->at(tid).first;
+    int p_offset = schema_index->at(s)[aid];
+    return (tuple_index->at(tid).second)[p_offset];
+}
+
+#endif
diff --git a/util/partitions/partition.cpp b/util/partitions/partition.cpp
new file mode 100644
index 0000000..5d4d75d
--- /dev/null
+++ b/util/partitions/partition.cpp
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "partition.h"
+#include "profiler.h"
+#include <fstream>
+#include <iostream>
+
+template<typename T>
+Partition<T>::Partition(char* buffer, bool deleteable){
+    this->buf = buffer;
+    this->deleteable = deleteable;
+
+    this->partition_id = *(int*)buffer;		// partition_id
+    buffer += sizeof(int);
+
+    std::string s(buffer, ANUM);
+    std::bitset<ANUM> cols(s);
+    this->cols = cols;						// bitmap
+    buffer += ANUM; 
+
+    uint64_t seg_num = *(uint64_t*)buffer;			// number of segments
+    buffer += sizeof(uint64_t);
+
+
+    this->tuple_num = *(uint64_t*)buffer;		//number of tuples
+    buffer += sizeof(uint64_t);
+
+    segments.reserve(seg_num);
+    for (uint64_t i = 0; i < seg_num; i++){
+        //Segment constructor moves the buffer to the next segment
+        segments.push_back(Segment<T>(buffer)); 
+    }
+}
+
+template<typename T>
+Partition<T>::~Partition(){
+    if(deleteable)
+        delete[] buf;
+}
+
+
+Profiler io_profiler[128];
+
+template<typename T>
+Partition<T>* Partition<T>::readFromFile(unsigned short threadid
+        , const char* filename){
+    
+    io_profiler[threadid].start_timer();
+
+    ifstream infile(filename, ios::binary);        
+	infile.seekg(0, ios::end);
+	size_t size = infile.tellg();
+	infile.seekg(0, ios::beg);
+
+	char *buffer = new char[size];
+	infile.read(buffer, size);
+    if(infile.gcount() != size){
+        infile.close();
+        cout << "initialize error" << endl;
+    }
+    infile.close();
+
+	Partition<T> *p = new Partition<T>(buffer, true);
+    
+    io_profiler[threadid].stop_timer();
+    io_profiler[threadid].add_io_size(size);
+
+    return p;
+}
+
+template class Partition<VTYPE>;
diff --git a/util/partitions/partition.h b/util/partitions/partition.h
new file mode 100644
index 0000000..0092678
--- /dev/null
+++ b/util/partitions/partition.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PARTITION__
+#define __PARTITION__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <bitset>
+#include <vector>
+
+#include "constants.h"
+#include "segment.h"
+
+template<typename T>
+class Partition{
+
+private:
+    int partition_id;
+    int tuple_num;
+    bitset<ANUM> cols;
+    vector<Segment<T>> segments;
+
+    char* buf;
+    bool deleteable;
+
+public:
+    Partition(char* buffer, bool deleteable);
+    ~Partition();
+
+    static Partition<T>* readFromFile(unsigned short threadid
+            , const char* filename);
+    void getSegments(vector<Segment<T>>& seg){
+        seg = this->segments;
+    }
+};
+
+#endif
diff --git a/util/partitions/partitionquery.cc b/util/partitions/partitionquery.cc
new file mode 100644
index 0000000..babe0f0
--- /dev/null
+++ b/util/partitions/partitionquery.cc
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "partitionquery.h"
+#include <sstream>
+#include <bits/stdc++.h>
+
+template<typename T>
+uint64_t PQuery<T>::next_qid = 0;
+
+template<typename T>
+PQuery<T>::PQuery(uint64_t qid, const vector<int>& projection
+                , const vector<int>& selection
+                , const vector<T>& ranges
+                , const bitset<2*ANUM>& closed){
+
+    this->qid = qid;
+    for(auto& i : projection)
+        this->projection[i] = 1;
+    for(auto& i : selection)
+        this->selection[i] = 1;
+    this->ranges = ranges;
+    this->closed = closed;
+    this->sel_v = selection;
+}
+
+template<typename T>
+PQuery<T>::PQuery(uint64_t qid, const bitset<ANUM>& projection
+        , const bitset<ANUM>& selection
+        , const vector<T>& ranges
+        , const bitset<2*ANUM>& closed){
+
+    this->qid = qid;
+    this->projection = projection;
+    this->selection = selection;
+    this->ranges = ranges;
+    this->closed = closed;
+
+    for(int i = 0; i < ANUM; i++)
+        if(selection[i] == 1)
+            sel_v.push_back(i);
+
+}
+
+template<typename T>
+PQuery<T>* PQuery<T>::parse_string(string str){
+    stringstream ss(str);
+    string token;
+
+    ss >> token;
+    reverse(token.begin(), token.end());
+    bitset<ANUM> projection(token);
+
+    ss >> token;
+    reverse(token.begin(), token.end());
+    bitset<ANUM> selection(token);
+
+
+//   projection = projection & (projection ^ selection);
+
+   vector<T> ranges;
+   ranges.reserve(2*ANUM);
+   for(int i = 0; i < 2*ANUM; i++){
+       ranges.push_back(0);
+       ss >> ranges[i];
+   }
+
+   ss >> token;
+   reverse(token.begin(), token.end());
+   bitset<2*ANUM> closed(token);
+
+   PQuery<T>* q = new PQuery<T>(next_qid++, projection
+           , selection, ranges, closed);
+   return q;
+}
+
+
+template<typename T>
+vector<int> PQuery<T>::getSelection(){
+    return sel_v;
+}
+
+template<typename T>
+vector<int> PQuery<T>::getProjection(){
+    vector<int> ret;
+    for(int i = 0; i < ANUM; i++)
+        if(projection[i] == 1)
+            ret.push_back(i);
+    return ret;
+}
+
+template<typename T>
+void PQuery<T>::evaluate(T data[], uint64_t tnum
+        , vector<T> &ret, vector<uint64_t>& tids){
+    ret.clear();
+    vector<int> proj_v;
+    for(int i = 0; i < ANUM; i++)
+        if(projection[i] == 1)
+            proj_v.push_back(i);
+
+    T sel_data[sel_v.size()];
+    for(uint64_t i = 0; i < tnum; i++){
+        for(int j = 0; j < sel_v.size(); j++)
+            sel_data[j] = data[i*ANUM + sel_v[j]];
+        if(!this->evaluate(sel_data))
+            continue;
+        for(auto j : proj_v)
+            ret.push_back(data[i*ANUM + j]);
+        tids.push_back(i);
+    }
+}
+
+template class PQuery<VTYPE>;
diff --git a/util/partitions/partitionquery.h b/util/partitions/partitionquery.h
new file mode 100644
index 0000000..78e9289
--- /dev/null
+++ b/util/partitions/partitionquery.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __QUERY__
+#define __QUERY__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <bitset>
+#include <vector>
+#include <stdint.h>
+
+#include "constants.h"
+
+using namespace std;
+
+template <typename T>
+class PQuery{
+public:
+
+    PQuery(uint64_t qid, const vector<int>& projection
+            , const vector<int>& selection
+            , const vector<T>& ranges
+            , const bitset<2*ANUM>& closed);
+
+    PQuery(uint64_t qid, const bitset<ANUM>& projection
+            , const bitset<ANUM>& selection
+            , const vector<T>& ranges
+            , const bitset<2*ANUM>& closed);
+
+    vector<int> getSelection();
+    vector<int> getProjection();
+
+    /*
+     * Check the data in selection attributes satisfy the query
+     * The lenght of sel_data is same as the number of selection attrs
+     */
+    bool evaluate(T sel_data[]);
+
+    bool evaluate(T sel_data[], const vector<int>& aids);
+
+    /*
+     * Evaluate a set of tuples and place proj attrs of satisfied tuples in ret
+     */
+    void evaluate(T data[], uint64_t tnum, vector<T> &ret, vector<uint64_t> &tids);
+
+    static PQuery<T>* parse_string(string str);
+
+    bitset<ANUM> projection;
+    bitset<ANUM> selection;
+    vector<int> sel_v;
+    vector<T> ranges;
+    bitset<2*ANUM> closed; //the range is closed or not
+    uint64_t qid;
+
+private:
+    static uint64_t next_qid;
+};
+
+template<typename T>
+inline bool PQuery<T>::evaluate(T data[]){
+    for(int i = 0; i < sel_v.size(); i++){
+        T v = data[i];
+        uint64_t aid = sel_v[i];
+        T l(ranges[2*aid]), r(ranges[2*aid+1]);
+        if(v < l || (v == l && closed[2*aid] == 0))
+            return false;
+        if(v > r || (v == r && closed[2*aid + 1] == 0))
+            return false;
+    }
+    return true;
+}
+
+template<typename T>
+inline bool PQuery<T>::evaluate(T data[], const vector<int>& aid){
+    for(int i = 0; i < aid.size(); i++){
+        T v = data[i];
+        int a = aid[i];
+        T l(ranges[2*a]), r(ranges[2*a + 1]);
+        if(v < l || (v == l && closed[2*a] == 0))
+            return false;
+        if(v > r || (v == r && closed[2*a + 1] == 0))
+            return false;
+    }
+    return true;
+}
+
+#endif
diff --git a/util/partitions/profiler.cc b/util/partitions/profiler.cc
new file mode 100644
index 0000000..816dee2
--- /dev/null
+++ b/util/partitions/profiler.cc
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "profiler.h"
+
+void Profiler::start_timer(){
+    gettimeofday(&start_time, NULL);
+}
+
+void Profiler::stop_timer(){
+
+    struct timeval end;
+    
+    gettimeofday(&end, NULL);
+    double t = (1000000 * ( end.tv_sec - start_time.tv_sec )
+            + end.tv_usec -start_time.tv_usec) /1000000.0;
+    
+    time += t;
+}
+
+void Profiler::add_io_size(uint64_t size){
+    io_size += size;
+    io_num ++;
+}
+
+void Profiler::clear(){
+    time = 0;
+    io_size = 0;
+    io_num = 0;
+}
+
+void Profiler::add(const Profiler& b){
+    this->time += b.time;
+    this->io_size += b.io_size;
+    this->io_num += b.io_num;
+}
diff --git a/util/partitions/profiler.h b/util/partitions/profiler.h
new file mode 100644
index 0000000..475fc78
--- /dev/null
+++ b/util/partitions/profiler.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __TIMER__
+#define __TIMER__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <sys/time.h>
+using namespace std;
+
+class Profiler{
+
+public:
+    Profiler(): time(0), io_size(0), io_num(0) {}
+
+    void start_timer();
+    void stop_timer();
+    void add_io_size(uint64_t size);
+
+    double getTime(){return time;}
+    uint64_t getIOSize(){return io_size;}
+    uint64_t getIONum() {return io_num;}
+
+    void add(const Profiler& b);
+
+    void clear();
+
+private:
+    double time;
+    uint64_t io_size;
+    uint64_t io_num;
+    struct timeval start_time;
+
+};
+
+#endif
diff --git a/util/partitions/profiler_cycle.cpp b/util/partitions/profiler_cycle.cpp
new file mode 100644
index 0000000..4f2dc86
--- /dev/null
+++ b/util/partitions/profiler_cycle.cpp
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "profiler_cycle.h"
+
+void ProfilerCycle::init(int threadnum, int op_num){
+    start_clock.clear();
+    cycles.clear();
+    io_size.clear();
+    io_num.clear();
+
+    for(int i = 0; i < threadnum; i++){
+        vector<unsigned long long> s;
+        for(int j = 0; j < op_num; j++)
+            s.push_back(0);
+        start_clock.push_back(s);
+        cycles.push_back(s);
+        io_size.push_back(0);
+        io_num.push_back(0);
+    }
+}
+
+void ProfilerCycle::add_io_size(int threadid, uint64_t size){
+    io_size[threadid] += size;
+    io_num[threadid] ++;
+}
diff --git a/util/partitions/profiler_cycle.h b/util/partitions/profiler_cycle.h
new file mode 100644
index 0000000..9dd1494
--- /dev/null
+++ b/util/partitions/profiler_cycle.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PROFILER_CYCLE__
+#define __PROFILER_CYCLE__
+
+#include "../../rdtsc.h"
+#include <vector>
+#include <string>
+using namespace std;
+
+class ProfilerCycle{
+public:
+    void init(int threadnum, int operator_num);
+    inline void start(int threadid, int operator_id);
+    inline void stop(int threadid, int operator_id);
+    
+    void add_io_size(int threadid, uint64_t size);
+   
+    // threads * operators 
+    vector<vector<unsigned long long>> cycles;
+    
+    vector<uint64_t> io_size;
+    vector<uint64_t> io_num;
+private:
+    vector<vector<unsigned long long>> start_clock;
+};
+
+inline
+void ProfilerCycle::start(int threadid, int operator_id){
+    start_clock[threadid][operator_id] = curtick();
+}
+
+inline
+void ProfilerCycle::stop(int threadid, int operator_id){
+    cycles[threadid][operator_id] += 
+        curtick() - start_clock[threadid][operator_id];
+}
+#endif
diff --git a/util/partitions/profiler_trace.cc b/util/partitions/profiler_trace.cc
new file mode 100644
index 0000000..8fd25e5
--- /dev/null
+++ b/util/partitions/profiler_trace.cc
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "profiler_trace.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+void ProfilerTrace::init(int threadnum){
+    tnum = threadnum;
+    ticks.resize(tnum);
+}
+
+void ProfilerTrace::print(){
+    for(int i = 0; i < ticks.size(); i++)
+        for(auto p : ticks[i])
+            printf("Thread %d %s at %llu\n", i, p.first.c_str()
+                    , p.second);
+}
+
+void ProfilerTrace::clear(){
+    ticks.clear();
+    ticks.resize(tnum);
+}
diff --git a/util/partitions/profiler_trace.h b/util/partitions/profiler_trace.h
new file mode 100644
index 0000000..1d3f9dc
--- /dev/null
+++ b/util/partitions/profiler_trace.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __PROFILER_TRACE__
+#define __PROFILER_TRACE__
+
+#include "../../rdtsc.h"
+#include <vector>
+#include <string>
+#include <utility>
+#include <sys/time.h>
+using namespace std;
+
+class ProfilerTrace{
+public:
+    void init(int threadnum);
+    void add(int tid, string name){
+        /*
+        struct timeval time;
+        gettimeofday(&time, NULL);
+        unsigned long long t = 1000000*time.tv_sec + time.tv_usec;
+        ticks[tid].push_back(std::make_pair(name, t));
+        */
+        ticks[tid].push_back(std::make_pair(name, curtick()));
+    }
+
+    void print();
+    void clear();
+ 
+    //threads * operators 
+    vector<vector<std::pair<string, unsigned long long>>> ticks;
+private:
+    int tnum;
+};
+
+#endif
diff --git a/util/partitions/readdummy.cpp b/util/partitions/readdummy.cpp
new file mode 100644
index 0000000..858855f
--- /dev/null
+++ b/util/partitions/readdummy.cpp
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "readdummy.h"
+
+#include <pthread.h>
+#include <fstream>
+
+void read_dummy(int thread_num, string path, int filenum, uint64_t size){
+
+    read_dummy_params td[thread_num];
+    pthread_t threads[thread_num];
+    pthread_attr_t attr;
+    void* status;
+    int rc;
+
+    pthread_attr_init(&attr);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+    for(int i = 0; i < thread_num; i++){
+        td[i].path = path;
+        td[i].thread_id = i;
+        td[i].thread_num = thread_num;
+        td[i].file_num = filenum;
+        td[i].file_size = size;
+
+        rc = pthread_create(&threads[i], &attr, read_dummy
+                , (void*)&(td[i]));
+    }
+
+    for(int i = 0; i < thread_num; i++)
+        rc = pthread_join(threads[i], &status);
+
+    pthread_attr_destroy(&attr);
+}
+
+void* read_dummy(void* args){
+    read_dummy_params* input = (read_dummy_params*) args;
+
+    char* buffer = new char[input->file_size];
+
+    for(int i = input->thread_id; i < input->file_num
+            ; i+= input->thread_num){
+        string path = input->path + to_string(i);
+        ifstream ifile(path.c_str(), ios::binary);
+        ifile.read(buffer, input->file_size);
+        ifile.close();
+    }
+    delete[] buffer;
+    pthread_exit(NULL);
+    return NULL;
+}
diff --git a/util/partitions/readdummy.h b/util/partitions/readdummy.h
new file mode 100644
index 0000000..71d2ab4
--- /dev/null
+++ b/util/partitions/readdummy.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __READDUMMY__
+#define __READDUMMY__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string>
+#include <cstdint>
+using namespace std;
+
+void read_dummy(int threadnum, string dir, int filenum, uint64_t size);
+
+void* read_dummy(void* args);
+
+struct read_dummy_params{
+    string path;
+    int thread_id;
+    int thread_num;
+    int file_num;
+    uint64_t file_size;
+};
+
+#endif
diff --git a/util/partitions/segment.cpp b/util/partitions/segment.cpp
new file mode 100644
index 0000000..a2a63fe
--- /dev/null
+++ b/util/partitions/segment.cpp
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "segment.h"
+
+template<typename T>
+Segment<T>::Segment(char* &buffer){
+	this->buf = buffer;
+
+    this->segment_id = *(uint64_t*)buffer;
+	buffer += sizeof(uint64_t);
+
+	std::string s(buffer, ANUM);
+    std::bitset<ANUM> cols(s);
+	this->cols = cols;
+	buffer += ANUM;
+
+	this->col_num = this->cols.count();
+    this->tuple_size = sizeof(uint64_t) + sizeof(T) * col_num;
+	
+    this->tuple_num = *(uint64_t*)buffer;
+	buffer += sizeof(uint64_t);
+    
+    this->data = buffer;
+    
+    buffer += this->tuple_size * this->tuple_num;
+}
+
+template class Segment<VTYPE>;
diff --git a/util/partitions/segment.h b/util/partitions/segment.h
new file mode 100644
index 0000000..d483da2
--- /dev/null
+++ b/util/partitions/segment.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2020, Jigsaw authors (see AUTHORS file).
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * 
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived from
+ * this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __SEGMENT__
+#define __SEGMENT__
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <cstdint>
+#include <bitset>
+
+#include "constants.h"
+
+using namespace std;
+
+template<typename T>
+class Segment{
+
+private:
+    uint64_t segment_id;
+    bitset<ANUM> cols;
+    uint64_t tuple_num;
+    int col_num;
+    int tuple_size;
+
+    char* buf;
+    char* data;
+
+public:
+    Segment(char* &buf);
+
+    uint64_t getTupleNum() {return this->tuple_num; }
+    bitset<ANUM> getColumns() {return this->cols; }
+    inline uint64_t getTuple(uint64_t tuple_off, T* &ptr);
+
+    uint64_t getSegmentID() {return segment_id; }
+};
+
+template<typename T>
+inline uint64_t Segment<T>::getTuple(uint64_t tuple_off, T* &ptr){
+    char* p = this->data + tuple_off * this->tuple_size;
+    uint64_t tid = *(uint64_t*)p;
+    ptr = (T*)(p + sizeof(uint64_t));
+    return tid;
+}
+
+#endif
